<?xml version="1.0"?>
<TEI>
	<teiHeader>
		<fileDesc>
			<titleStmt>
				<title>Database development mistakes made by application developers [closed]</title>
				<author>Charles Faiga</author>
			</titleStmt>
			<publicationStmt>
				<p>Open Source</p>
			</publicationStmt>
			<sourceDesc>
				<p>Pulled from StackOverflow: http://stackoverflow.com/questions/621884/database-development-mistakes-made-by-application-developers/621891
				Date Pulled: March 6th, 2015 at 10:08 AM				
				</p>
			</sourceDesc>
		</fileDesc>
		<listPerson>
				<person xml:id="George Milliken" url="http://stackoverflow.com/users/530864/george-milliken">
				<signatureContent>
					<p>Reputation: <num>86</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num></num>
					Number of Bronze Badges:<num>4</num></p>
				</signatureContent>
				</person>
				<person xml:id="chefsmart" url="http://stackoverflow.com/users/46928/chefsmart">
				<signatureContent>
					<p>Reputation: <num>2,564</num>
					Number of Gold Badges: <num>4</num>
					Number of Silver Badges:<num>24</num>
					Number of Bronze Badges:<num>38</num></p>
				</signatureContent>
				</person>
				<person xml:id="Peter Mortensen" url="http://stackoverflow.com/users/63550/peter-mortensen">
				<signatureContent>
					<p>Reputation: <num>7,966</num>
					Number of Gold Badges: <num>9</num>
					Number of Silver Badges:<num>56</num>
					Number of Bronze Badges:<num>90</num></p>
				</signatureContent>
				<person xml:id="Charles Faiga" url="http://stackoverflow.com/users/17560/charles-faiga">
				<signatureContent>
					<p>Reputation: <num>5242</num>
					Number of Gold Badges: <num>14</num>
					Number of Silver Badges:<num>72</num>
					Number of Bronze Badges:<num>121</num></p>	
				</signatureContent>
				</person>
				<person xml:id="cletus" url="http://stackoverflow.com/users/18393/cletus">
				<signatureContent>
					<p>Reputation: <num>302,016</num>
					Number of Gold Badges: <num>92</num>
					Number of Silver Badges:<num>672</num>
					Number of Bronze Badges:<num>824</num></p>
				</signatureContent>
				</person>
				<person xml:id="ConcernedOfTunbridgeWells" url="http://stackoverflow.com/users/15401/concernedoftunbridgewells">
				<signatureContent>
					<p>Reputation: <num>39,446</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>93</num>
					Number of Bronze Badges:<num>161</num></p>
				</signatureContent>
				</person>
				<person xml:id="tszming" url="http://stackoverflow.com/users/325314/tszming">
				<signatureContent>
					<p>Reputation: <num></num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num></num>
					Number of Bronze Badges:<num></num></p>
				</signatureContent>
				</person>
				<person xml:id="Pratik" url="http://stackoverflow.com/users/11711/pratik">
				<signatureContent>
					<p>Reputation: <num>6,071</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>25</num>
					Number of Bronze Badges:<num>41</num></p>
				</signatureContent>
				</person>
				<person xml:id="Test223345555" url="http://stackoverflow.com/users/656660/test223345555">
				<signatureContent>
					<p>Reputation: <num>1</num>
					Number of Gold Badges: <num>0</num>
					Number of Silver Badges:<num>0</num>
					Number of Bronze Badges:<num>1</num></p>
				</signatureContent>
				</person>
				<person xml:id="sdc" url="http://stackoverflow.com/users/648517/sdc">
				<signatureContent>
					<p>Reputation: <num>89</num>
					Number of Gold Badges: <num>0</num>
					Number of Silver Badges:<num>0</num>
					Number of Bronze Badges:<num>2</num></p>
				</signatureContent>
				</person>
				</person>
				<person xml:id="jwiscarson" url="http://stackoverflow.com/users/277136/jwiscarson">
				<signatureContent>
					<p>Reputation: <num>2,232</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>16</num>
                    Number of Bronze Badges:<num>35</num></p>
				</signatureContent>
				</person>
				<person xml:id="Oakcool" url="http://stackoverflow.com/users/99175/oakcool">
				<signatureContent>
					<p>Reputation: <num>802</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>7</num>
					Number of Bronze Badges:<num>21</num></p>
				</signatureContent>
				</person>
				<person xml:id="jcampbell1" url="http://stackoverflow.com/users/20512/jcampbell1">
				<signatureContent>
					<p>Reputation: <num>jcampbell1</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>15</num>
					Number of Bronze Badges:<num>25</num></p>
				</signatureContent>
				</person>
				<person xml:id="Robin" url="http://stackoverflow.com/users/60234/robin">
				<signatureContent>
					<p>Reputation: <num>1,900</num>
					Number of Gold Badges: <num>0</num>
					Number of Silver Badges:<num>11</num>
					Number of Bronze Badges:<num>24</num></p>
				</signatureContent>
				</person>
				<person xml:id="jfar" url="http://stackoverflow.com/users/25300/jfar">
				<signatureContent>
					<p>Reputation: <num>19.9k</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>47</num>
					Number of Bronze Badges:<num>88</num></p>
				</signatureContent>
				</person>
				<person xml:id="Nick Anderegg" url="http://stackoverflow.com/users/553508/nick-anderegg">
				<signatureContent>
					<p>Reputation: <num>387</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>18</num></p>
				</signatureContent>
				</person>
			<person xml:id="Sriram" url="http://stackoverflow.com/users/98251/sriram">
				<signatureContent>
					<p>Reputation: <num>622</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>13	</num></p>
				</signatureContent>
				</person>
				<person xml:id="DOK" url="http://stackoverflow.com/users/27637/dok">
				<signatureContent>
					<p>Reputation: <num>22,234</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>37</num>
					Number of Bronze Badges:<num>77</num></p>
				</signatureContent>
				</person>
				<person xml:id="Shane H" url="http://stackoverflow.com/users/60247/shane-h">
				<signatureContent>
					<p>Reputation: <num>1,210</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>11</num>
					Number of Bronze Badges:<num>22</num></p>
				</signatureContent>
				</person>
				<person xml:id="Michael Easter" url="http://stackoverflow.com/users/12704/michael-easter">
				<signatureContent>
					<p>Reputation: <num>8,106</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>24</num>
					Number of Bronze Badges:<num>57</num></p>
				</signatureContent>
				</person>
				<person xml:id="Einstein" url="http://stackoverflow.com/users/41898/einstein">
				<signatureContent>
					<p>Reputation: <num>3,074</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>11</num>
					Number of Bronze Badges:<num>17</num></p>
				</signatureContent>
				</person>
				<person xml:id="David T. Macknet" url="http://stackoverflow.com/users/6850/david-t-macknet">
				<signatureContent>
					<p>Reputation: <num>971</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>8</num>
					Number of Bronze Badges:<num>18</num></p>
				</signatureContent>
				</person>
				<person xml:id="jonesy" url="http://stackoverflow.com/users/243611/jonesy">
				<signatureContent>
					<p>Reputation: <num>2,246</num>
					Number of Gold Badges: <num></num>
				    Number of Silver Badges:<num>6</num>
					Number of Bronze Badges:<num>17</num></p>
				</signatureContent>
				</person>
				<person xml:id="Benoit" url="http://stackoverflow.com/users/10703/benoit">
				<signatureContent>
					<p>Reputation: <num>14,738</num>
					Number of Gold Badges: <num>10</num>
				    Number of Silver Badges:<num>56</num>
					Number of Bronze Badges:<num>88</num></p>
				</signatureContent>
				</person>
				<person xml:id="recursive" url="http://stackoverflow.com/users/44743/recursive">
				<signatureContent>
					<p>Reputation: <num>38,647</num>
					Number of Gold Badges: <num>12</num>
					Number of Silver Badges:<num>73</num>
					Number of Bronze Badges:<num>157</num></p>
				</signatureContent>
				</person>
				<person xml:id="Bill Karwin" url="http://stackoverflow.com/users/20860/bill-karwin">
				<signatureContent>
					<p>Reputation: <num>233,068</num>
					Number of Gold Badges: <num>41</num>
					Number of Silver Badges:<num>324</num>
					Number of Bronze Badges:<num>491</num></p>
				</signatureContent>
				</person>
				<person xml:id="p.campbell" url="http://stackoverflow.com/users/23199/p-campbell">
				<signatureContent>
					<p>Reputation: <num>46,759</num>
					Number of Gold Badges: <num>40</num>
					Number of Silver Badges:<num>154</num>
					Number of Bronze Badges:<num>244</num></p>
				</signatureContent>
				</person>
				<person xml:id="David Lively" url="http://stackoverflow.com/users/135769/david-lively">
				<signatureContent>
					<p>Reputation: <num>16,841</num>
					Number of Gold Badges: <num>7</num>
					Number of Silver Badges:<num>50</num>
					Number of Bronze Badges:<num>108</num></p>
				</signatureContent>
				</person>
			<person xml:id="Zsolt Török" url="http://stackoverflow.com/users/108781/zsolt-t%C3%B6r%C3%B6k">
				<signatureContent>
					<p>Reputation: <num>3,966</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>16</num>
					Number of Bronze Badges:<num>22</num></p>
				</signatureContent>
				</person>
				<person xml:id="Skatterbrainz" url="http://stackoverflow.com/users/498341/skatterbrainz">
				<signatureContent>
					<p>Reputation: <num>352</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>13</num>
					Number of Bronze Badges:<num>25</num></p>
				</signatureContent>
				</person>
				<person xml:id="jamolkhon" url="http://stackoverflow.com/users/66611/jamolkhon">
				<signatureContent>
					<p>Reputation: <num>1,535</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>19</num>
					Number of Bronze Badges:<num>24</num></p>
				</signatureContent>
				</person>
				<person xml:id="Vimvq1987" url="http://stackoverflow.com/users/79109/vimvq1987">
				<signatureContent>
					<p>Reputation: <num>4,711</num>
					Number of Gold Badges: <num>17</num>
					Number of Silver Badges:<num>60</num>
					Number of Bronze Badges:<num>109</num></p>
				</signatureContent>
				</person>
				<person xml:id="ZeroBugBounce" url="http://stackoverflow.com/users/11314/zerobugbounce">
				<signatureContent>
					<p>Reputation: <num>2,467</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>14</num>
					Number of Bronze Badges:<num>35</num></p>
				</signatureContent>
				</person>
				<person xml:id="pbailey19" url="http://stackoverflow.com/users/144729/pbailey19">
				<signatureContent>
					<p>Reputation: <num>128</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>1</num>
					Number of Bronze Badges:<num>7</num></p>
				</signatureContent>
				</person>
				<person xml:id="HLGEM" url="http://stackoverflow.com/users/9034/hlgem">
				<signatureContent>
					<p>Reputation: <num>58,902</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>54</num>
					Number of Bronze Badges:<num>107</num></p>
				</signatureContent>
				</person>
				<person xml:id="John Nilsson" url="http://stackoverflow.com/users/24243/john-nilsson">
				<signatureContent>
					<p>Reputation: <num>5,419</num>
					Number of Gold Badges: <num>6</num>
					Number of Silver Badges:<num>21</num>
					Number of Bronze Badges:<num>33</num></p>
				</signatureContent>
				</person>
				<person xml:id="Adam Jaskiewicz" url="http://stackoverflow.com/users/35322/adam-jaskiewicz">
				<signatureContent>
					<p>Reputation: <num>7,840</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>21</num>
					Number of Bronze Badges:<num>30</num></p>
				</signatureContent>
				</person>
				<person xml:id="finnw" url="http://stackoverflow.com/users/12048/finnw">
				<signatureContent>
					<p>Reputation: <num>26.7k</num>
					Number of Gold Badges: <num>13</num>
				    Number of Silver Badges:<num>79</num>
					Number of Bronze Badges:<num>156</num></p>
				</signatureContent>
				</person>
				<person xml:id="Nathan Voxland" url="http://stackoverflow.com/users/45756/nathan-voxland">
				<signatureContent>
					<p>Reputation: <num>6,790</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>17</num>
					Number of Bronze Badges:<num>36</num></p>
				</signatureContent>
				</person>
				<person xml:id="WhoIsNinja" url="http://stackoverflow.com/users/538091/whoisninja">
				<signatureContent>
					<p>Reputation: <num>1,107</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>20</num>
					Number of Bronze Badges:<num>49</num></p>
				</signatureContent>
				</person>
				<person xml:id="FrankComputerAtYmailDotCom" url="http://stackoverflow.com/users/366797/frankcomputeratymaildotcom">
				<signatureContent>
					<p>Reputation: <num>1,057</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>14</num>
					Number of Bronze Badges:<num>44</num></p>
				</signatureContent>
				</person>
				<person xml:id="CStroliaDavis" url="http://stackoverflow.com/users/630249/cstroliadavis">
				<signatureContent>
					<p>Reputation: <num>179</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>2</num>
					Number of Bronze Badges:<num>14</num></p>
				</signatureContent>
				</person>
				<person xml:id="Dustin" url="http://stackoverflow.com/users/39975/dustin">
				<signatureContent>
					<p>Reputation: <num>39,615</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>71</num>
					Number of Bronze Badges:<num>111</num></p>
				</signatureContent>
				</person>
				<person xml:id="Ash" url="http://stackoverflow.com/users/5023/ash">
				<signatureContent>
					<p>Reputation: <num>34k</num>
					Number of Gold Badges: <num>22</num>
					Number of Silver Badges:<num>103</num>
					Number of Bronze Badges:<num>149</num></p>
				</signatureContent>
				</person>
				<person xml:id="Rob Whelan" irl="http://stackoverflow.com/users/187807/rob-whelan">
				<signatureContent>
					<p>Reputation: <num>667</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>8</num>
					Number of Bronze Badges:<num>12</num></p>
				</signatureContent>
				</person>
				<person xml:id="Sinthia V" url="http://stackoverflow.com/users/963791/sinthia-v">
				<signatureContent>
					<p>Reputation: <num>1,244</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>6</num>
					Number of Bronze Badges:<num>31</num></p>
				</signatureContent>
				</person>
				<person xml:id="TheTXI" url="http://stackoverflow.com/users/22164/thetxi">
				<signatureContent>
					<p>Reputation: <num>25.8k</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>60</num>
					Number of Bronze Badges:<num>97</num></p>
				</signatureContent>
				</person>
				<person xml:id="ML--" url="http://stackoverflow.com/users/359861/ml">
				<signatureContent>
					<p>Reputation: <num>77</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>1</num>
					Number of Bronze Badges:<num>8</num></p>
				</signatureContent>
				</person>
				<person xml:id="Kb." url="http://stackoverflow.com/users/49544/kb">
				<signatureContent>
					<p>Reputation: <num>3,294</num>
					Number of Gold Badges: <num>9</num>
					Number of Silver Badges:<num>37</num>
					Number of Bronze Badges:<num>68</num></p>
				</signatureContent>
				</person>
				<person xml:id="Tegiri Nenashi" url="http://stackoverflow.com/users/432426/tegiri-nenashi">
				<signatureContent>
					<p>Reputation: <num>1,614</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>7</num>
					Number of Bronze Badges:<num>15</num></p>
				</signatureContent>
				</person>
				<person xml:id="adam" url="http://stackoverflow.com/users/150262/adam">
				<signatureContent>
					<p>Reputation: <num>31</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>2</num>
					Number of Bronze Badges:<num>5</num></p>
				</signatureContent>
				</person>
				<person xml:id="Christophe Herreman" url="http://stackoverflow.com/users/17255/christophe-herreman">
				<signatureContent>
					<p>Reputation: <num>12.1k</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>39</num>
					Number of Bronze Badges:<num>69</num></p>
				</signatureContent>
				</person>
				<person xml:id="Bob Moore" url="http://stackoverflow.com/posts/622004/revisions">
				<signatureContent>
					<p>Reputation: <num>4,622</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>15</num>
					Number of Bronze Badges:<num>27</num></p>
				</signatureContent>
				</person>
				<person xml:id="ВГДЕЖЅZЗИІКЛМНОПҀРСТȢѸФХ">
				<signatureContent>
					<p>Reputation: <num>11,234</num>
				    Number of Gold Badges: <num>15</num>
					Number of Silver Badges:<num>70</num>
					Number of Bronze Badges:<num>127</num></p>
				</signatureContent>
				</person>
				<person xml:id="davidcl" url="http://stackoverflow.com/users/36754/davidcl">
				<signatureContent>
					<p>Reputation: <num>739</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>6</num>
					Number of Bronze Badges:<num>23</num></p>
				</signatureContent>
				</person>
				<person xml:id="Ash" url="http://stackoverflow.com/users/5023/ash">
				<signatureContent>
					<p>Reputation: <num>34,048</num>
					Number of Gold Badges: <num>22</num>
					Number of Silver Badges:<num>103</num>
					Number of Bronze Badges:<num>149</num></p>
				</signatureContent>
				</person>
				<person xml:id="Warren P" url="http://stackoverflow.com/users/84704/warren-p">
				<signatureContent>
					<p>Reputation: <num>25,552</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>85</num>
					Number of Bronze Badges:<num>171</num></p>
				</signatureContent>
				</person>
				<person xml:id="too" url="http://stackoverflow.com/users/291496/too">
				<signatureContent>
					<p>Reputation: <num>1,441</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>10</num>
					Number of Bronze Badges:<num>26</num></p>
				</signatureContent>
				</person>
				<person xml:id="NotMe" url="http://stackoverflow.com/users/2424/notme">
				<signatureContent>
					<p>Reputation: <num>62,312</num>
					Number of Gold Badges: <num>17</num>
					Number of Silver Badges:<num>100</num>
					Number of Bronze Badges:<num>184</num></p>
				</signatureContent>
				</person>
				<person xml:id="Chris Simpson" url="http://stackoverflow.com/users/28896/chris-simpson">
				<signatureContent>
					<p>Reputation: <num>4,172</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>30</num>
					Number of Bronze Badges:<num>51</num></p>
				</signatureContent>
				</person>
				<person xml:id="George Mauer" url="http://stackoverflow.com/users/5056/george-mauer">
				<signatureContent>
					<p>Reputation: <num>27,226</num>
					Number of Gold Badges: <num>57</num>
					Number of Silver Badges:<num>108</num>
					Number of Bronze Badges:<num>385</num></p>
				</signatureContent>
				</person>
				<person xml:id="Rad" url="http://stackoverflow.com/users/1349/rad">
				<signatureContent>
					<p>Reputation: <num>6,430</num>
					Number of Gold Badges: <num>4</num>
					Number of Silver Badges:<num>26</num>
					Number of Bronze Badges:<num>30</num></p>
				</signatureContent>
				</person>
				<person xml:id="Ixmatus" url="http://stackoverflow.com/users/128382/ixmatus">
				<signatureContent>
					<p>Reputation: <num>591</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>15</num></p>
				</signatureContent>
				</person>
				<person xml:id="David Atkinson" url="http://stackoverflow.com/users/167364/david-atkinson">
				<signatureContent>
					<p>Reputation: <num>2,698</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>13</num>
					Number of Bronze Badges:<num>15</num></p>
				</signatureContent>
				</person>
				<person xml:id="Niyaz" url="http://stackoverflow.com/users/184/niyaz">
				<signatureContent>
					<p>Reputation: <num>18,067</num>
					Number of Gold Badges: <num>36</num>
					Number of Silver Badges:<num>109</num>
					Number of Bronze Badges:<num>161</num></p>
				</signatureContent>
				</person>
				<person xml:id="Joe Van Dyk" url="http://stackoverflow.com/users/17076/joe-van-dyk">
				<signatureContent>
					<p>Reputation: <num>2,894</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>26</num>
					Number of Bronze Badges:<num>52</num></p>
				</signatureContent>
				</person>
				<person xml:id="RJD22" url="http://stackoverflow.com/users/255920/rjd22">
				<signatureContent>
					<p>Reputation: <num>7,212</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>14</num>
					Number of Bronze Badges:<num>29	</num></p>
				</signatureContent>
				</person>
				<person xml:id="CStroliaDavis" url="http://stackoverflow.com/users/630249/cstroliadavis">
				<signatureContent>
					<p>Reputation: <num>179</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>2</num>
					Number of Bronze Badges:<num>14</num></p>
				</signatureContent>
				</person>
				<person xml:id="Lazer" url="http://stackoverflow.com/users/113124/lazer">
				<signatureContent>
					<p>Reputation: <num>18,368</num>
					Number of Gold Badges: <num>48</num>
					Number of Silver Badges:<num>177</num>
					Number of Bronze Badges:<num>286</num></p>
				</signatureContent>
				</person>
				<person xml:id="Tegiri Nenashi" url="http://stackoverflow.com/users/432426/tegiri-nenashi">
				<signatureContent>
					<p>Reputation: <num>1,614</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>7</num>
					Number of Bronze Badges:<num>15</num></p>
				</signatureContent>
				</person>
				<person xml:id="dotjoe" url="http://stackoverflow.com/users/40822/dotjoe">
				<signatureContent>
					<p>Reputation: <num>13,283</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>35</num>
					Number of Bronze Badges:<num>54</num></p>
				</signatureContent>
				</person>
				<person xml:id="Craig Young" url="http://stackoverflow.com/users/224704/craig-young">
				<signatureContent>
					<p>Reputation: <num>6,410</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>14</num>
					Number of Bronze Badges:<num>29</num></p>
				</signatureContent>
				</person>
				<person xml:id="Greg" url="http://stackoverflow.com/users/13009/greg">
				<signatureContent>
					<p>Reputation: <num>8,709</num>
					Number of Gold Badges: <num>41</num>
					Number of Silver Badges:<num>130</num>
					Number of Bronze Badges:<num>212</num></p>
				</signatureContent>
				</person>
				<person xml:id="cafebabe" url="http://stackoverflow.com/users/123584/cafebabe">
				<signatureContent>
					<p>Reputation: <num>1,096</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>8</num></p>
				</signatureContent>
				</person>
				<person xml:id="Mikael Sundberg" url="http://stackoverflow.com/users/125927/mikael-sundberg">
				<signatureContent>
					<p>Reputation: <num>499</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>10</num></p>
				</signatureContent>
				</person>
				<person xml:id="mykhal" url="http://stackoverflow.com/users/234248/mykhal">
				<signatureContent>
					<p>Reputation: <num>6,618</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>37</num>
					Number of Bronze Badges:<num>58</num></p>
				</signatureContent>
				</person>
				<person xml:id="Thomas" url="http://stackoverflow.com/users/198643/thomas">
				<signatureContent>
					<p>Reputation: <num>44,880</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>45</num>
					Number of Bronze Badges:<num>79</num></p>
				</signatureContent>
				</person>
				<person xml:id="James Jones" url="http://stackoverflow.com/users/84088/james-jones">
				<signatureContent>
					<p>Reputation: <num>3,606</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>20</num>
					Number of Bronze Badges:<num>36</num></p>
				</signatureContent>
				</person>
				<person xml:id="whybird" url="http://stackoverflow.com/users/156118/whybird">
				<signatureContent>
					<p>Reputation: <num>828</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>5</num>
					Number of Bronze Badges:<num>17</num></p>
				</signatureContent>
				</person>
				<person xml:id="araqnid" url="http://stackoverflow.com/users/85134/araqnid">
				<signatureContent>
					<p>Reputation: <num>39,094</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>72</num>
					Number of Bronze Badges:<num>81</num></p>
				</signatureContent>
				</person>
				<person xml:id="nos" url="http://stackoverflow.com/users/126769/nos">
				<signatureContent>
					<p>Reputation: <num>114,579</num>
					Number of Gold Badges: <num>27</num>
					Number of Silver Badges:<num>181</num>
					Number of Bronze Badges:<num>307</num></p>
				</signatureContent>
				</person>
				<person xml:id="Peter Bailey" url="http://stackoverflow.com/users/8815/peter-bailey">
				<signatureContent>
					<p>Reputation: <num>68,917</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num></num>
					Number of Bronze Badges:<num></num></p>
				</signatureContent>
				</person>
				<person xml:id="Rakesh Sharma" url="http://stackoverflow.com/users/878888/rakesh-sharma">
				<signatureContent>
					<p>Reputation: <num></num></p>
					Number of Gold Badges: <num>20</num>
					Number of Silver Badges:<num>120</num>
					Number of Bronze Badges:<num>161</num></p>
				</signatureContent>
				</person>
				<person xml:id="prinzdezibe" url="http://stackoverflow.com/users/49628/prinzdezibel">
				<signatureContent>
					<p>Reputation: <num>3,695</num>
					Number of Gold Badges: <num>10</num>
					Number of Silver Badges:<num>38</num>
					Number of Bronze Badges:<num>56</num></p>
				</signatureContent>
				</person>
				<person xml:id="Frederik Gheysels" url="http://stackoverflow.com/users/55774/frederik-gheysels">
				<signatureContent>
					<p>Reputation: <num>38,342</num>
					Number of Gold Badges: <num>4</num>
					Number of Silver Badges:<num>57</num>
					Number of Bronze Badges:<num>117</num></p>
				</signatureContent>
				</person>
				<person xml:id="jim" url="http://stackoverflow.com/users/27628/jim">
				<signatureContent>
					<p>Reputation: <num>1,053</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>8</num>
					Number of Bronze Badges:<num>11</num></p>
				</signatureContent>
				</person>
				<person xml:id="Zurahn" url="http://stackoverflow.com/users/23666/zurahn">
				<signatureContent>
					<p>Reputation: <num>5,327</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>22</num>
					Number of Bronze Badges:<num>30</num></p>
				</signatureContent>
				</person>
				</listPerson>
	</teiHeader>
	<text>
		<body>
		<div type="forum">
			<post when="" who="Charles Faiga" revisedBy="community wiki" revisedWhen="Sep 13 '10 at 19:19" upVote="566" accepted="favorite">
			<p>What are common database development mistakes made by application developers?

			<tag>database</tag> <tag>database-design</tag>
			</p>
			</post>	
		</div>		
		<div type="moderator">
			<head>locked by Bill the Lizard♦ Feb 26 '12 at 21:41</head>
			<post when="Feb 26 '12 at 21:41" who="Bill the Lizard♦">
			 	<p>This question exists because it has historical significance, but it is not considered a good, on-topic question for this site, so please do not use it as evidence that you can ask similar questions here. This question and its answers are frozen and cannot be changed. More info: help center.
			 	</p>
			</post>
			</div>
			<div type="moderator">
			<head>closed as not constructive by Sam Saffron, Paŭlo Ebermann Oct 5 '11 at 1:06</head>
			<post when="Oct 5 '11 at 1:06" who="Sam Saffron">
			 	<p>As it currently stands, this question is not a good fit for our Q&amp;A format. We expect answers to be supported by facts, references, or expertise, but this question will likely solicit debate, arguments, polling, or extended discussion. If you feel that this question can be improved and possibly reopened, visit the help center for guidance.
				If this question can be reworded to fit the rules in the help center, please edit the question.
			 	</p>
			</post>
			</div>
			<div type="response">
				<post when="Mar 8 '09 at 4:46" who="dkretz" indentLevel="1">  
					<p>Near-duplicate of stackoverflow.com/questions/346659/…   
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="" who="cletus" revisedWhen="Sep 17 '13 at 16:51" revisedBy="community wiki" upVote="1003" accepted="accepted">
			 	<p>1. Not using appropriate indices

					This is a relatively easy one but still it happens all the time. Foreign keys should have indexes on them. If you're using a field in a WHERE you should (probably) have an index on it. Such indexes should often cover multiple columns based on the queries you need to execute.

					2. Not enforcing referential integrity

					Your database may vary here but if your database supports referential integrity--meaning that all foreign keys are guaranteed to point to an entity that exists--you should be using it.

					It's quite common to see this failure on MySQL databases. I don't believe MyISAM supports it. InnoDB does. You'll find people who are using MyISAM or those that are using InnoDB but aren't using it anyway.

					More here:

					How important are constraints like NOT NULL and FOREIGN KEY if I’ll always control my database input with php?
					Are foreign keys really necessary in a database design?
					Are foreign keys really necessary in a database design?
					3. Using natural rather than surrogate (technical) primary keys

					Natural keys are keys based on externally meaningful data that is (ostensibly) unique. Common examples are product codes, two-letter state codes (US), social security numbers and so on. Surrogate or technical primary keys are those that have absolutely no meaning outside the system. They are invented purely for identifying the entity and are typically auto-incrementing fields (SQL Server, MySQL, others) or sequences (most notably Oracle).

					In my opinion you should always use surrogate keys. This issue has come up in these questions:

					How do you like your primary keys?
					What's the best practice for primary keys in tables?
					Which format of primary key would you use in this situation.
					Surrogate vs. natural/business keys
					Should I have a dedicated primary key field?
					This is a somewhat controversial topic on which you won't get universal agreement. While you may find some people, who think natural keys are in some situations OK, you won't find any criticism of surrogate keys other than being arguably unnecessary. That's quite a small downside if you ask me.

					Remember, even countries can cease to exist (for example, Yugoslavia).

					4. Writing queries that require DISTINCT to work

					You often see this in ORM-generated queries. Look at the log output from Hibernate and you'll see all the queries begin with:

					SELECT DISTINCT ...
					This is a bit of a shortcut to ensuring you don't return duplicate rows and thus get duplicate objects. You'll sometimes see people doing this as well. If you see it too much it's a real red flag. Not that DISTINCT is bad or doesn't have valid applications. It does (on both counts) but it's not a surrogate or a stopgap for writing correct queries.

					From Why I Hate DISTINCT:

					Where things start to go sour in my opinion is when a developer is building substantial query, joining tables together, and all of a sudden he realizes that it looks like he is getting duplicate (or even more) rows and his immediate response...his "solution" to this "problem" is to throw on the DISTINCT keyword and POOF all his troubles go away.
					5. Favouring aggregation over joins

					Another common mistake by database application developers is to not realize how much more expensive aggregation (ie the GROUP BY clause) can be compared to joins.

					To give you an idea of how widespread this is, I've written on this topic several times here and been downvoted a lot for it. For example:

					From SQL statement - “join” vs “group by and having”:

					First query:

					SELECT userid
					FROM userrole
					WHERE roleid IN (1, 2, 3)
					GROUP by userid
					HAVING COUNT(1) = 3
					Query time: 0.312 s

					Second query:

					SELECT t1.userid
					FROM userrole t1
					JOIN userrole t2 ON t1.userid = t2.userid AND t2.roleid = 2
					JOIN userrole t3 ON t2.userid = t3.userid AND t3.roleid = 3
					AND t1.roleid = 1
					Query time: 0.016 s

					That's right. The join version I proposed is twenty times faster than the aggregate version.
					6. Not simplifying complex queries through views

					Not all database vendors support views but for those that do, they can greatly simplify queries if used judiciously. For example, on one project I used a generic Party model for CRM. This is an extremely powerful and flexible modelling technique but can lead to many joins. In this model there were:

					Party: people and organisations;
					Party Role: things those parties did, for example Employee and Employer;
					Party Role Relationship: how those roles related to each other.
					Example:

					Ted is a Person, being a subtype of Party;
					Ted has many roles, one of which is Employee;
					Intel is an organisation, being a subtype of a Party;
					Intel has many roles, one of which is Employer;
					Intel employs Ted, meaning there is a relationship between their respective roles.
					So there are five tables joined to link Ted to his employer. You assume all employees are Persons (not organisations) and provide this helper view:

					CREATE VIEW vw_employee AS
					SELECT p.title, p.given_names, p.surname, p.date_of_birth, p2.party_name employer_name
					FROM person p
					JOIN party py ON py.id = p.id
					JOIN party_role child ON p.id = child.party_id
					JOIN party_role_relationship prr ON child.id = prr.child_id AND prr.type = 'EMPLOYMENT'
					JOIN party_role parent ON parent.id = prr.parent_id = parent.id
					JOIN party p2 ON parent.party_id = p2.id
					And suddenly you have a very simple view of the data you want but on a highly flexible data model.

					7. Not sanitizing input

					This is a huge one. Now I like PHP but if you don't know what you're doing it's really easy to create sites vulnerable to attack. Nothing sums it up better than the story of little Bobby Tables.

					Data provided by the user by way of URLs, form data and cookies should always be treated as hostile and sanitized. Make sure you're getting what you expect.

					8. Not using prepared statements

					Prepared statements are when you compile a query minus the data used in inserts, updates and WHERE clauses and then supply that later. For example:

					SELECT * FROM users WHERE username = 'bob'
					vs

					SELECT * FROM users WHERE username = ?
					or

					SELECT * FROM users WHERE username = :username
					depending on your platform.

					I've seen databases brought to their knees by doing this. Basically, each time any modern database encounters a new query it has to compile it. If it encounters a query it's seen before, you're giving the database the opportunity to cache the compiled query and the execution plan. By doing the query a lot you're giving the database the opportunity to figure that out and optimize accordingly (for example, by pinning the compiled query in memory).

					Using prepared statements will also give you meaningful statistics about how often certain queries are used.

					Prepared statements will also better protect you against SQL injection attacks.

					9. Not normalizing enough

					Database normalization is basically the process of optimizing database design or how you organize your data into tables.

					Just this week I ran across some code where someone had imploded an array and inserted it into a single field in a database. Normalizing that would be to treat element of that array as a separate row in a child table (ie a one-to-many relationship).

					This also came up in Best method for storing a list of user IDs:

					I've seen in other systems that the list is stored in a serialized PHP array.
					But lack of normalization comes in many forms.

					More:

					Normalization: How far is far enough?
					SQL by Design: Why You Need Database Normalization
					10. Normalizing too much

					This may seem like a contradiction to the previous point but normalization, like many things, is a tool. It is a means to an end and not an end in and of itself. I think many developers forget this and start treating a "means" as an "end". Unit testing is a prime example of this.

					I once worked on a system that had a huge hierarchy for clients that went something like:

					Licensee ->  Dealer Group -> Company -> Practice -> ...
					such that you had to join about 11 tables together before you could get any meaningful data. It was a good example of normalization taken too far.

					More to the point, careful and considered denormalization can have huge performance benefits but you have to be really careful when doing this.

					More:

					Why too much Database Normalization can be a Bad Thing
					How far to take normalization in database design?
					When Not to Normalize your SQL Database
					Maybe Normalizing Isn't Normal
					The Mother of All Database Normalization Debates on Coding Horror
					11. Using exclusive arcs

					An exclusive arc is a common mistake where a table is created with two or more foreign keys where one and only one of them can be non-null. Big mistake. For one thing it becomes that much harder to maintain data integrity. After all, even with referential integrity, nothing is preventing two or more of these foreign keys from being set (complex check constraints notwithstanding).

					From A Practical Guide to Relational Database Design:

					We have strongly advised against exclusive arc construction wherever possible, for the good reason that they can be awkward to write code and pose more maintenance difficulties.
					12. Not doing performance analysis on queries at all

					Pragmatism reigns supreme, particularly in the database world. If you're sticking to principles to the point that they've become a dogma then you've quite probably made mistakes. Take the example of the aggregate queries from above. The aggregate version might look "nice" but its performance is woeful. A performance comparison should've ended the debate (but it didn't) but more to the point: spouting such ill-informed views in the first place is ignorant, even dangerous.

					13. Over-reliance on UNION ALL and particularly UNION constructs

					A UNION in SQL terms merely concatenates congruent data sets, meaning they have the same type and number of columns. The difference between them is that UNION ALL is a simple concatenation and should be preferred wherever possible whereas a UNION will implicitly do a DISTINCT to remove duplicate tuples.

					UNIONs, like DISTINCT, have their place. There are valid applications. But if you find yourself doing a lot of them, particularly in subqueries, then you're probably doing something wrong. That might be a case of poor query construction or a poorly designed data model forcing you to do such things.

					UNIONs, particularly when used in joins or dependent subqueries, can cripple a database. Try to avoid them whenever possible.

					14. Using OR conditions in queries

					This might seem harmless. After all, ANDs are OK. OR should be OK too right? Wrong. Basically an AND condition restricts the data set whereas an OR condition grows it but not in a way that lends itself to optimisation. Particularly when the different OR conditions might intersect thus forcing the optimizer to effectively to a DISTINCT operation on the result.

					Bad:

					... WHERE a = 2 OR a = 5 OR a = 11
					Better:

					... WHERE a IN (2, 5, 11)
					Now your SQL optimizer may effectively turn the first query into the second. But it might not. Just don't do it.

					15. Not designing their data model to lend itself to high-performing solutions

					This is a hard point to quantify. It is typically observed by its effect. If you find yourself writing gnarly queries for relatively simple tasks or that queries for finding out relatively straightforward information are not efficient, then you probably have a poor data model.

					In some ways this point summarizes all the earlier ones but it's more of a cautionary tale that doing things like query optimisation is often done first when it should be done second. First and foremost you should ensure you have a good data model before trying to optimize the performance. As Knuth said:
		
					Premature optimization is the root of all evil
					16. Incorrect use of Database Transactions

					All data changes for a specific process should be atomic. I.e. If the operation succeeds, it does so fully. If it fails, the data is left unchanged. - There should be no possibility of 'half-done' changes.

					Ideally, the simplest way to achieve this is that the entire system design should strive to support all data changes through single INSERT/UPDATE/DELETE statements. In this case, no special transaction handling is needed, as your database engine should do so automatically.

					However, if any processes do require multiple statements be performed as a unit to keep the data in a consistent state, then appropriate Transaction Control is necessary.

					Begin a Transaction before the first statement.
					Commit the Transaction after the last statement.
					On any error, Rollback the Transaction. And very NB! Don't forget to skip/abort all statements that follow after the error.
					Also recommended to pay careful attention to the subtelties of how your database connectivity layer, and database engine interact in this regard.

					17. Not understanding the 'set-based' paradigm

					The SQL language follows a specific paradigm suited to specific kinds of problems. Various vendor-specific extensions notwithstanding, the language struggles to deal with problems that are trivial in langues like Java, C#, Delphi etc.

					This lack of understanding manifests itself in a few ways.

					Inappropriately imposing too much procedural or imperative logic on the databse.
					Inappropriate or excessive use of cursors. Especially when a single query would suffice.
					Incorrectly assuming that triggers fire once per row affected in multi-row updates.
					Determine clear division of responsibility, and strive to use the appropriate tool to solve each problem.
			 	</p>
				</post>
			</div>
			<div type="response">
				<post when="Mar 7 '09 at 14:36" who="Niyaz" indentLevel="1">  
					<p>Good points. Can somebody elaborate on the points?      
					</p>				
				</post>
			</div>
			<div type="response">
				<post when="Mar 8 '09 at 4:39" who="Zurahn" indentLevel="1" upVote="9">     
					<p>On the MySQL statements about foreign keys, you're right that MyISAM doesn't support them, but you imply that merely using MyISAM is bad design. A reason I've used MyISAM is that InnoDB doesn't support FullText searches, and I don't think that's unreasonable.  
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Mar 8 '09 at 4:58" who="cletus" indentLevel="1">  
					<p>I don't mean to imply that MyISAM is bad, just that you don't have that option if you're using MyISAM.   
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Apr 9 '09 at 9:35" who="jim" indentLevel="1">  
					<p>Do not use Social Security Numbers as keys ! (Unless you are the Social Security Administration) Yes they are unique however they CAN change and they can be "reused".  
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Apr 11 '09 at 21:48" who="Frederik Gheysels" indentLevel="1">  
					<p>Wasn't it dijkstra who said that premature optimization is the root of all evil ?   
					</p>				
				</post>
			</div>
			<div type="response">     
				<post when="Apr 18 '09 at 7:12" who="prinzdezibel" indentLevel="1">  
					<p>Agree except #4 -Let me borrow a response to 'Why I hate DISTINCT': Developers have be so ass whipped by management and sales people deciding on how the code should be written and how long it should take to write, a 'distinct' can be a great friend. A developer doesn't care that some over paid marketing head bought a junk list of data with tons of dupes. He just wants to load it and get on with his life. Developers are just trying to keep their hours under 60 a week and occasionally see sunlight  
					</p>				
				</post>
			</div>
			<div type="response">
				<post when="Jun 5 '09 at 7:48" who="Peter Bailey" indentLevel="1" upVote="1" >  
					<p>I have to ask about #6. Using views like this is one of my favorite things to do, but I recently learned, to my horror, that with MySQL indexes on the underlying tables are only obeyed if the structure of the view allows use of the merge algorithm. Otherwise, a temp table is used and all your indexes are useless. It's even more alarming when you realize that a bunch of operations cause this behavior. It's a great way to turn a .01 sec query into to a 100 second one. Does anyone else here have experience with this? Check the links in my next comment.   
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Jun 5 '09 at 7:48" who="Peter Bailey" indentLevel="1">  
					<p>MySQL View algos dev.mysql.com/doc/refman/5.0/en/view-algorithms.html MySQL View Performance mysqlperformanceblog.com/2007/08/12/…   
					</p>				
				</post>
			</div>
			<div type="response">  
				<post when="Sep 5 '09 at 23:38" who="nos" indentLevel="1" upVote="59" >  
					<p>You're missing one important item here, Not using transactions. I've seen so many cases of insert/updates that needs to be wrapped in a transaction - the only thing keeping the system from breaking horribly is there hasn't been concurrent updates to those records - Yet. (or noone have yet noticed the broken data)    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Sep 6 '09 at 19:08" who="Bill Karwin" indentLevel="1">  
					<p>@Frederik Gheysels: shreevatsa.wordpress.com/2008/05/16/… for info on the premature optimization quote. The origin of the quote is not totally clear, but seems likely to have been first used by Knuth.   
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Dec 16 '09 at 0:38" who="araqnid" indentLevel="1">  
					<p>Odd, I've used Hibernate a lot and it doesn't routinely add "distinct" on the front of queries. I wouldn't use it if it did!    
					</p>				
				</post>
			</div>
			<div type="response">  
				<post when="Dec 16 '09 at 3:52" who="whybird" indentLevel="1" upVote="2" >  
					<p>Shouldn't this be 14 separate answers so they can be votedd on effectively?   
					</p>				
				</post>
			</div>
			<div type="response">
				<post when="Apr 21 '10 at 13:48" who=" James Jones" indentLevel="1" upVote="32" >  
					<p>I think this post needs to be normalized..      
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Aug 2 '10 at 17:32" who="Thomas" indentLevel="1" upVote="5" >  
					<p>Completely disagree with #3. Yes, countries can cease to exist, but the country code will continue to represent the same thing. Same with currency codes or US States. It is dumb to use a surrogate key in these cases and creates more overhead in your queries as you must include an extra join. I would say that it is safer to say that you probably ought to use a surrogate for user-specific data (thus, not countries, currencies and US States).   
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Aug 2 '10 at 17:34" who="Thomas" indentLevel="1" upVote="1" >  
					<p>RE: #11 The check constraint needed to enforce data integrity is trivial. There are other reasons for avoiding that design, but the need for "complex" check constraint isn't one of them.   
					</p>				
				</post>
			</div>
			<div type="response">     
				<post when="Aug 28 '10 at 20:51" who="mykhal" indentLevel="1">  
					<p>i think that using natural keys could leat to less optimal - sparse - internal database index structure, while autoincremented index would be compact. please correct me, if i'm wrong   
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Aug 29 '10 at 12:26" who="John Nilsson" indentLevel="1">  
					<p>With oracle (10.2) it can be better to actually not use a prepared statement for some queries. Consider hardcoding the argument values if the query is heavy (over a minute execution time) and realtively rare (once a day).    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Nov 24 '10 at 19:17" who="Mikael Sundberg" indentLevel="1">  
					<p>I dissagree on foreign keys. This depends to much on the load type of the database. If your application is write heavy, foreign keys will cost alot of performance.    
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Dec 13 '10 at 9:39" who="Dustin" indentLevel="1">  
					<p>Sanitizing input is the wrong thing to do. You cannot scrub the input to make it safe for database consumption, you can only supply it out of band (via parameterized queries). It's safer, easier and faster.    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Dec 13 '10 at 13:28" who="cafebabe" indentLevel="1">  
					<p>"13. Using OR conditions in queries" ... with Oracle, you better use boolean (ORed / ANDed) concatination when you dont have a subquery. Otherwise, you end up with high CPU utilization and slow performance. So using the rule for the IN-Statement does not apply everytime.    
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Dec 13 '10 at 15:32" who="Shane H" indentLevel="1">  
					<p>@Peter Bailey: I agree. "Use Views" is bad advice. It's more complex. If a DB supports materialized views, then definitely, use views. Use them liberally. If a DB does not, do not use views. And while MySQL claims they have materialized views, upon closer examination, they do not, not in the ways that matter, not in the way Oracle, MSSQL and PGSQL do.    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Dec 13 '10 at 15:49" who="Shane H" indentLevel="1" upVote="2" >  
					<p>With #3 you are not being honest. There are more downsides to the artificial key than "you may not need it." Specifically, using a natural key will give you the ability to control the order in which data in your table is written to the disk. If you know how your table will be queried, you can index it so concurrently-accessed rows will end-up in the same page. Furthermore, you can enforce data integrity using a unique composite index. If you need this you will have to add it in addition to your artificial key index. If said composite index is your pkey it's 2 birds killed with one stone.   
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Jan 4 '11 at 20:57" who="user201788" indentLevel="1" upVote="1" >  
					<p>This answer needs to go into some Wiki or somewhere...on well, it is in my favorites now. :)    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Jan 17 '11 at 3:18" who="Greg" indentLevel="1">  
					<p>I don't see how your two queries for #5 are the same. Would you mind explaining it a bit?   
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Jan 27 '11 at 7:56" who="Р̀СТȢѸ́ФХѾЦЧШЩЪЫЬѢѤЮѦѪѨѬѠѺѮѰѲѴ" indentLevel="1">  
					<p>This is one of the answers that should be voted for Great Answers to be put on the main page, as an article from which other users will learn    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Apr 22 '11 at 13:34" who="Craig Young" indentLevel="1" upVote="1" >  
					<p>@Greg: Provided the joins are inner joins, and there are no duplicate by userid, roleid - both queries will produce the exact same result set. 1) This query filters roleid IN (1,2,3), and counts them up per userid. The HAVING clause filters only those users with all 3 roles. 2) This query joins lists of users for each role by userid. INNER JOINS means that any user missing any one of the roles will be excluded. So the final list has only those users with all 3 roles.   
					</p>				
				</post>
			</div>
			<div type="response">
				<post when="May 12 '11 at 19:00" who="dotjoe" indentLevel="1">  
					<p>RE #4 Is it just Hibernate? Because I've never seen this with NHibernate as of version 2.       
					</p>				
				</post>
			</div>
			<div type="response">     
				<post when="Jun 13 '11 at 14:32" who="David T. Macknet" indentLevel="1">  
					<p>Regarding #3 I must quibble a bit. Sure, go ahead and give yourself a surrogate, but don't mark that as the primary key, because that's not what a primary key IS - a primary key is "what the record is about," not simply a programming aid. Build a unique index on your surrogate key and use that for relationships, fine, but it's not a primary key. Regarding #10: there are good reasons to normalize, not least of which is that the data structures will then reflect the entities you're trying to model. You may have to build some views to make life easier, but don't be a data slob for convenience!    
					</p>				
				</post>
			</div>
			<div type="response">   
				<post when="Jul 27 '11 at 23:29" who="Tegiri Nenashi" indentLevel="1">  
					<p>-1 #14 The queries are equivalent: if query planner in your favorite database tells you otherwise, fire your db vendor.    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Aug 12 '11 at 21:30" who="Lazer" indentLevel="1">  
					<p>@cletus: Awesome answer, one question though, how do prepared statements protect against SQL injection attacks?    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Jan 13 '12 at 15:11" who="CStroliaDavis" indentLevel="1">  
					<p>On this issue with #3. While I would normally say it's rarely a good idea to say something is "always" the best way to do something, I would say that with primary keys in databases, because of the way that data is stored, with any table of significant size that is expected to continue to grow, surrogate keys are nearly always the best choice. I sympathize with @david-t-macknet about what the data is about, but in large tables, sorting your physical data by a natural key could end up taking a long time in tables with millions of rows. A PK on a surrogate identity always sorts to the end.    
					</p>				
				</post>
			</div>
			<div type="response">     
				<post when="Jan 26 '12 at 14:22" who="RJD22" indentLevel="1">  
					<p>Re: #5 Most likely the slowdown doesn't get generated by your group by but because you are using HAVING. The use of having gets run after it got all the data. So it is a lot slower than just skipping while gathering data.   
					</p>				
				</post>
			</div>
			<div type="response">     
				<post when="Feb 2 '12 at 7:48" who="Joe Van Dyk" indentLevel="1">  
					<p>I disagree on exclusive arcs being hard to maintain. If I have three foreign keys in the arc, I can do (in postgres): check ((table1_id is not null)::integer + (table2_id is not null)::integer + (table3_id is not null)::integer = 1)    
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="" who="ConcernedOfTunbridgeWells" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:23" upVote="110" >
			 	<p>Key database design and programming mistakes made by developers

				Selfish database design and usage. Developers often treat the database as their personal persistent object store without considering the needs of other stakeholders in the data. This also applies to application architects. Poor database design and data integrity makes it hard for third parties working with the data and can substantially increase the system's life cycle costs. Reporting and MIS tends to be a poor cousin in application design and only done as an afterthought.

				Abusing denormalised data. Overdoing denormalised data and trying to maintain it within the application is a recipe for data integrity issues. Use denormalisation sparingly. Not wanting to add a join to a query is not an excuse for denormalising.

				Scared of writing SQL. SQL isn't rocket science and is actually quite good at doing its job. O/R mapping layers are quite good at doing the 95% of queries that are simple and fit well into that model. Sometimes SQL is the best way to do the job.

				Dogmatic 'No Stored Procedures' policies. Regardless of whether you believe stored procedures are evil, this sort of dogmatic attitude has no place on a software project.

				Not understanding database design. Normalisation is your friend and it's not rocket science. Joining and cardinality are fairly simple concepts - if you're involved in database application development there's really no excuse for not understanding them.
			 	</p>
				</post>
			</div>
			<div type="response">
				<post when="Mar 12 '09 at 14:50" who="HLGEM" indentLevel="1" upVote="3" >  
					<p>I'd give you a 1000 upvotes if I could for that first point especially    
					</p>				
				</post>
				</div>
				<div type="response">  
				<post when="Jul 13 '09 at 22:58" who="Chris Simpson" indentLevel="1" upVote="2" >   
					<p>One might argue that transactions should be done in transactional database and reporting and MIS should be done in a separate analysis database. Therefore you get the best of both worlds and everyone is happy (except for the poor mug who has to write the data transformation script to build the latter out of the former). 
					</p>			
				</post>
				</div>
				<div type="response">    
				<post when="Jul 13 '09 at 23:08" who="ConcernedOfTunbridgeWells" indentLevel="1" upVote="2" >       
					<p>Not just the poor mug writing the ETL - anyone using data from the system, the poor quality data in the MIS application that's boxed in because several key relationships aren't actually recorded at source, anyone involved in the endless reconciliation bun-fignts that ensue from the poor data quality. 
					</p>			
				</post>
				</div>
				<div type="response">
				<post when="Oct 20 '09 at 13:43" who="HLGEM" indentLevel="1">      
					<p>Hey writing ETL processes is FUN! (Ok so I'm a bit wierd but I do this for a living.)    
					</p>			
				</post>  
				</div>
				<div type="response"> 
				<post when="Oct 20 '09 at 16:32" who="ConcernedOfTunbridgeWells" indentLevel="1">   
					<p>From time to time I do too, although these days I tend to be drifting further into the dark abyss of consultancy (Your anger will make you strong ...). However, all too often I see operational systems designed with no thought to actually doing MIS off them. 
					</p>			
				</post> 
				</div>
				<div type="response">  
				<post when="Aug 5 '10 at 19:48" who="George Mauer" indentLevel="1">   
					<p> I could not possibly disagree more with point one. Databases are for persistence, they are not for inter-process communication. There are almost always better solutions to that problem. Unless there is an explicit requirement for it, you absolutely SHOULD treat the database as if nobody except for your application will ever use it. Even if there IS an explicit requirement, do some user story and root cause analysis on it and you will quite often discover a much better way of filling the requestor's intent. Then again, I do work at a company where the phrase CQRS is somewhat common 
					</p>			
				</post>
				</div>
				<div type="response">  
				<post when="Aug 7 '10 at 18:56" who="ConcernedOfTunbridgeWells" indentLevel="1" upVote="3" >   
					<p>Trivial example: I have an insurance policy administration system and need to load the state of 5 million claims into a ceded reinsurance system to calculate potential recoveries. The systems are older client-server COTS packages, designed to interface to even older mainframe systems. Both have to be reconciled for financial control purposes. This job is done once per month. By your logic I would write a series of user stories defining the requirements and ask the vendors to quote on adding a web service wrapper to their existing products. 
					</p>			
				</post>
				</div>
				<div type="response">   
				<post when=" Aug 7 '10 at 18:59" who="ConcernedOfTunbridgeWells" indentLevel="1">   
					<p>But then again, I do work in companies where phrases like 'Audit', 'FSA' and 'Sarbannes-Oxley' are somewhat common. 
					</p>			
				</post>
				</div>
				<div type="response">    
				<post when="Aug 12 '10 at 19:25" who="George Mauer" indentLevel="1">   
					<p>Wow, really? Let's be even snippier next time! Sounds like you already have a requirement to your vendors that their systems be accessible for bulk import operations, wouldn't it be better if this was stated explicitly than just by happenstance? 90% of the time if the two of you analyze this requirement, you will realize that there are a variety of ways they can deliver a product that achieves your goals. As for audit trails - that along with data mining are one of the origins of the discipline of cqrs, in its event sourcing incarnation it leaves perfect audit trails. 
					</p>			
				</post>
				</div>
				<div type="response">
				<post when="Jan 3 '11 at 12:18 " who="ConcernedOfTunbridgeWells" indentLevel="1" upVote="2" >   
					<p>Then your DBA is either lazy or incompetent.    
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="Mar 7 '09 at 15:33" who="Rad" revisedBy="community wiki" upVote="80" >
			 	<p>Not using version control on the database schema
					Working directly against a live database
					Not reading up and understanding more advanced database concepts (indexes, clustered indexes, constraints, materialized views, etc)
					Failing to test for scalability ... test data of only 3 or 4 rows will never give you the real picture of real live performance
			 	</p>
				</post>
			</div>
			<div type="response">   
				<post when="Dec 13 '10 at 17:52" who="Ixmatus" indentLevel="1" upVote="1" >   
					<p>I second, heavily, #1 and #2. Anytime I make a change to the DB I dump its schema and version it; I have three databases setup, a dev one, a staging one, and a live one - NOTHING ever gets "tested" on the live DB!! 
					</p>			
				</post>
				</div>
				<div type="response">       
				<post when="Jan 5 '11 at 12:32" who="David Atkinson" indentLevel="1">   
					<p>Here at Red Gate we've taken steps to improve your first point with SQL Source Control! From conversations I've had during my research I think people aren't developing against production databases anymore, but often "emergency" fixes are made that generally find their way back to development environments, which is another issue. 
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="" who="Ashley Henderson" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:24" upVote="46" >
			 	<p>Over-use and/or dependence on stored procedures.

					Some application developers see stored procedures as a direct extension of middle tier/front end code. This appears to be a common trait in Microsoft stack developers, (I'm one, but I've grown out of it) and produces many stored procedures that perform complex business logic and workflow processing. This is much better done elsewhere.

					Stored procedures are useful where it has actuallly been proven that some real technical factor necessitates their use (for example, performance and security) For example, keeping aggregation/filtering of large data sets "close to the data".

					I recently had to help maintain and enhance a large Delphi desktop application of which 70% of the business logic and rules were implemented in 1400 SQL Server stored procedures (the remainder in UI event handlers). This was a nightmare, primarily due to the difficuly of introducing effective unit testing to TSQL, lack of encapsulation and poor tools (Debuggers, editors).

					Working with a Java team in the past I quickly found out that often the complete opposite holds in that environment. A Java Architect once told me: "The database is for data, not code.".

					These days I think it's a mistake to not consider stored procs at all, but they should be used sparingly (not by default) in situations where they provide useful benefits (see the other answers).
			 	</p>
				</post>
			</div>
			<div type="response">    
				<post when="Jun 8 '10 at 18:00" who="Warren P" indentLevel="1" upVote="4" >   
					<p>Stored procedures tend to become an island of hurt in any project where they are used, thus some developers make a rule "No stored procedures". So it looks like there is an open conflict beteween them. Your answer makes a good case for when to actually choose one way, or the other. 
					</p>			
				</post>
				</div>
				<div type="response">  
				<post when="Apr 22 '11 at 14:50" who="NotMe" indentLevel="1">   
					<p>Benefits: security - you don't have to give applications the ability to "delete * from..."; tweaks - DBA's can tweak the queries without having to recompile/deploy the whole application; analysis - it's easy to recompile a bunch of procs after a data model change to ensure they are still valid; and, finally, considering SQL is executed by the database engine (not your application) then the concept of "database is for data, not code" is just retarded. 
					</p>			
				</post>
				</div>
				<div type="response">      
				<post when="Jun 13 '11 at 14:39" who="David T. Macknet" indentLevel="1">   
					<p>So, you'd enmesh your business logic in the UI, where it was divorced from the data being manipulated? This doesn't seem like such a good idea, particularly as data manipulation is most efficient when performed by the database server rather than by round-trips from the UI. That also means that it's more difficult to control the application because you can't rely on the database being in control of its data and potentially have different versions of a UI out there with different data manipulation going on. Not good. I don't let anything touch my data except through a stored procedure. 
					</p>			
				</post>
				</div>
				<div type="response">       
				<post when="Aug 14 '11 at 23:12" who="too" indentLevel="1">   
					<p>If there is a need for separation of business logic from the UI, multi tier-architectures can be used. Or, a library with business objects and logic, used by different apps/UIs. Stored procedures lock your data/business logic to a specific database, changing a database in this case is very costly. And huge cost is bad. 
					</p>			
				</post>
				</div>
				<div type="response">     
				<post when="Sep 7 '11 at 20:30" who="NotMe" indentLevel="1">   
					<p>@too: Changing a database in most cases is very costly. Nevermind the idea of losing out on the performance and security features a particular DBMS provides. Further, additional tiers add complexity and decrease performance and additional layers are tied to your particular language. Finally, it's more likely the language being used will change than a database server. 
					</p>			
				</post>
				</div>
				<div type="answer">
				<post when="Mar 7 '09 at 15:37" who="Bob Moore" revisedBy="community wiki" upVote="41" >
			 	<p>Number one problem? They only test on toy databases. So they have no idea that their SQL will crawl when the database gets big, and someone has to come along and fix it later (that sound you can hear is my teeth grinding).
			 	</p>
				</post>
			</div>
			<div type="response">
				<post when="Jan 6 '11 at 20:35" who="davidcl" indentLevel="1" upVote="2" >   
					<p>Size of the database is relevant, but a bigger issue is load-- even if you test on a real dataset you aren't testing performance of your queries when the database is under a production load, which can be a real eye-opener. 
					</p>			
				</post>
				</div>
				<div type="response">         
				<post when="Jan 27 '11 at 8:15" who="Р̀СТȢѸ́ФХѾЦЧШЩЪЫЬѢѤЮѦѪѨѬѠѺѮѰѲѴ" indentLevel="1" upVote="4" >   
					<p>I would say that database size is bigger issue than load. I've seen many times, that there were missing crucial indexes - never been performance problem during tests, because whole database fit into memory 
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="Mar 7 '09 at 14:19" who="Christophe Herreman" revisedBy="community wiki" upVote="31" >
			 	<p>Not using indexes.
			 	</p>
				</post>
			</div>
			<div type="response">     
				<post when="Mar 7 '09 at 16:14" who="Ash" indentLevel="1" upVote="5" >   
					<p>Nice one. Sadly it's more like "not even knowing that indexes exist".    
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="" who="adam" revisedBy="community wiki" revisedWhen="Dec 13 '10 at 15:48" upVote="28" >
			 	<p>Poor Performance Caused by Correlated Subqueries

				Most of the time you want to avoid correlated subqueries. A subquery is correlated if, within the subquery, there is a reference to a column from the outer query. When this happens, the subquery is executed at least once for every row returned and could be executed more times if other conditions are applied after the condition containing the correlated subquery is applied.

				Forgive the contrived example and the Oracle syntax, but let's say you wanted to find all the employees that have been hired in any of your stores since the last time the store did less than $10,000 of sales in a day.

				select e.first_name, e.last_name
				from employee e
				where e.start_date > 
        		(select max(ds.transaction_date)
        		 from daily_sales ds
		         where ds.store_id = e.store_id and
               ds.total &lt; 10000)
				The subquery in this example is correlated to the outer query by the store_id and would be executed for every employee in your system. One way that this query could be optimized is to move the subquery to an inline-view.

					select e.first_name, e.last_name
					from employee e,
				     (select ds.store_id,
			             max(s.transaction_date) transaction_date
				      from daily_sales ds
				      where ds.total &lt; 10000
				      group by s.store_id) dsx
				where e.store_id = dsx.store_id and
				      e.start_date > dsx.transaction_date
				In this example, the query in the from clause is now an inline-view (again some Oracle specific syntax) and is only executed once. Depending on your data model, this query will probably execute much faster. It would perform better than the first query as the number of employees grew. The first query could actually perform better if there were few employees and many stores (and perhaps many of stores had no employees) and the daily_sales table was indexed on store_id. This is not a likely scenario but shows how a correlated query could possibly perform better than an alternative.

				I've seen junior developers correlate subqueries many times and it usually has had a severe impact on performance. However, when removing a correlated subquery be sure to look at the explain plan before and after to make sure you are not making the performance worse.
			 	</p>
				</post>
			</div>
			<div type="response">        
				<post when="Dec 16 '10 at 4:11" who="Rob Whelan" indentLevel="1" upVote="1" >   
					<p>Great point, and to emphasize one of your related points -- test your changes. Learn to use explain plans (and see what the database is actually doing to execute your query, and what it costs), do your tests on a large dataset, and don't make your SQL overly-complex and unreadable/unmaintainable for an optimization that doesn't actually improve real performance. 
					</p>			
				</post>
				</div>
			<div type="response">         
				<post when="Jun 13 '11 at 14:40" who="David T. Macknet" indentLevel="1" upVote="1" >   
					<p>Agreed! I've only had one case in which a correlated subquery was more efficient, and that's in 16 years of writing SQL!     
					</p>			
				</post>
				</div>
				<div type="response">  
				<post when="Jul 27 '11 at 23:24" who="Tegiri Nenashi" indentLevel="1">   
					<p>-1 There is no inherently good and bad queries. Optimizer does this transformation when needed.     
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="Mar 7 '09 at 14:42" who="Kb." revisedBy="community wiki" upVote="21" >
			 	<p>In my experience:
					Not communicating with experienced DBAs.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="Nathan Voxland" revisedBy="community wiki" revisedWhen="Mar 8 '09 at 4:20" upVote="17" >
			 	<p>Using Access instead of a "real" database. There are plenty of great small and even free databases like SQL Express, MySQL, and SQLite that will work and scale much better. Apps often need to scale in unexpected ways.
			 	</p>
				</post>
			</div>
			<div type="response">        
				<post when="Oct 23 '11 at 15:49" who="Sinthia V" indentLevel="1">   
					<p>Hey! I've made a lot of money turning toys into tools.   
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="Mar 7 '09 at 14:16" who="TheTXI" revisedBy="community wiki" upVote="16" >
			 	<p>Forgetting to set up relationships between the tables. I remember having to clean this up when I first started working at my current employer.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Aug 2 '10 at 17:18" who="ML--" revisedBy="community wiki" upVote="14" >
			 	<p>Using Excel for storing (huge amounts of) data.

					I have seen companies holding thousands of rows and using multiple worksheets (due to the row limit of 65535 on previous versions of Excel).

					Excel is well suited for reports, data presentation and other tasks, but should not be treated as a database.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="HLGEM" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:28" upVote="14" >
			 	<p>I'd like to add: Favoring "Elegant" code over highly performing code. The code that works best against databases is often ugly to the application developer's eye.

					Believing that nonsense about premature optimization. Databases must consider performance in the original design and in any subsequent development. Performance is 50% of database design (40% is data integrity and the last 10% is security) in my opinion. Databases which are not built from the bottom up to perform will perform badly once real users and real traffic are placed against the database. Premature optimization doesn't mean no optimization! It doesn't mean you should write code that will almost always perform badly because you find it easier (cursors for example which should never be allowed in a production database unless all else has failed). It means you don't need to look at squeezing out that last little bit of performance until you need to. A lot is known about what will perform better on databases, to ignore this in design and development is short-sighted at best.
			 	</p>
				</post>
			</div>
			<div type="response">         
				<post when="Dec 16 '10 at 4:11" who="Rob Whelan" indentLevel="1" upVote="1" >   
					<p>Great point, and to emphasize one of your related points -- test your changes. Learn to use explain plans (and see what the database is actually doing to execute your query, and what it costs), do your tests on a large dataset, and don't make your SQL overly-complex and unreadable/unmaintainable for an optimization that doesn't actually improve real performance. 
					</p>			
				</post>
				</div>
			<div type="response">           
				<post when="Oct 21 '09 at 8:00" who="ConcernedOfTunbridgeWells" indentLevel="1" upVote="2" >   
					<p>+1 - Database programming involves optimising the behaviour of mechanical components. Note, however, that Knuth says premature optimisation is the root of all evil about 97% of the time (or words to that effect). Database design is one area where you really do have to think about this up front. 
					</p>			
				</post>
				</div>
			<div type="response">      
				<post when="Dec 16 '10 at 4:11" who="Rob Whelan" indentLevel="1" upVote="1" >   
					<p>Great point, and to emphasize one of your related points -- test your changes. Learn to use explain plans (and see what the database is actually doing to execute your query, and what it costs), do your tests on a large dataset, and don't make your SQL overly-complex and unreadable/unmaintainable for an optimization that doesn't actually improve real performance. 
					</p>			
				</post>
				</div>
			<div type="response">           
				<post when="Dec 16 '10 at 4:20" who="Rob Whelan" indentLevel="1" upVote="2" >   
					<p>Ahem... what you are talking about is optimization that is not premature. Some consideration of real usage is required from the beginning in database design (and application design as well, really). Knuth's rule is actually not trivial to follow, because you have to decide what's premature and what isn't -- it really comes down to "don't perform optimizations without data". The early performance-related decisions you're talking about have data -- certain designs will set unacceptable limits on future performance, and you can calculate them. 
					</p>			
				</post>
				</div>
			<div type="answer">
				<post when="Mar 7 '09 at 16:52" who="Ash" revisedBy="community wiki" upVote="13" >
			 	<p>Not using parameterized queries. They're pretty handy in stopping SQL Injection.

					This is a specific example of not sanitizing input data, mentioned in another answer.
			 	</p>
				</post>
			</div>
			<div type="response">      
				<post when="Dec 13 '10 at 9:38" who="Dustin" indentLevel="1" upVote="3" >  
					<p>Except sanitizing input is wrong. Sanitizing implies putting it somewhere where it can be dangerous. Parameterizing means keeping it out of the path of harm altogether. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Feb 23 '11 at 16:25" who="CStroliaDavis" revisedBy="community wiki" upVote="12" >
			 	<p>I hate it when developers use nested select statements or even functions the return the result of a select statement inside the "SELECT" portion of a query.

					I'm actually surprised I don't see this anywhere else here, perhaps I overlooked it, although @adam has a similar issue indicated.

					Example:

					SELECT
				    (SELECT TOP 1 SomeValue FROM SomeTable WHERE SomeDate = c.Date ORDER BY SomeValue desc) As FirstVal
				    ,(SELECT OtherValue FROM SomeOtherTable WHERE SomeOtherCriteria = c.Criteria) As SecondVal
					FROM
				    MyTable c
					In this scenario, if MyTable returns 10000 rows the result is as if the query just ran 20001 queries, since it had to run the initial query plus query each of the other tables once for each line of result.

					Developers can get away with this working in a development environment where they are only returning a few rows of data and the sub tables usually only have a small amount of data, but in a production environment, this kind of query can become exponentially costly as more data is added to the tables.

					A better (not necessarily perfect) example would be something like:

						SELECT
					     s.SomeValue As FirstVal
					    ,o.OtherValue As SecondVal
						FROM
					    MyTable c
					    LEFT JOIN (
				        SELECT SomeDate, MAX(SomeValue) as SomeValue
					        FROM SomeTable 
				        GROUP BY SomeDate
					     ) s ON c.Date = s.SomeDate
					    LEFT JOIN SomeOtherTable o ON c.Criteria = o.SomeOtherCriteria
						This allows database optimizers to shuffle the data together, rather than requery on each record from the main table and I usually find when I have to fix code where this problem has been created, I usually end up increasing the speed of queries by 100% or more while simultaneously reducing CPU and memory usage.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Mar 7 '09 at 16:52" who="FrankComputerAtYmailDotCom" revisedBy="community wiki" revisedWhen="Jun 14 '11 at 2:00" upVote="12" >
			 	<p>For SQL-based databases:

					Not taking advantage of CLUSTERED INDEXES or choosing the wrong column(s) to CLUSTER.
					Not using a SERIAL (autonumber) datatype as a PRIMARY KEY to join to a FOREIGN KEY (INT) in a parent/child table relationship.
					Not UPDATING STATISTICS on a table when many records have been INSERTED or DELETED.
					Not reorganizing (i.e. unloading, droping, re-creating, loading and re-indexing) tables when many rows have been inserted or deleted (some engines physically keep deleted rows in a table with a delete flag.)
					Not taking advantage of FRAGMENT ON EXPRESSION (if supported) on large tables which have high transaction rates.
					Choosing the wrong datatype for a column!
					Not choosing a proper column name.
					Not adding new columns at the end of the table.
					Not creating proper indexes to support frequently used queries.
					creating indexes on columns with few possible values and creating unnecessary indexes.
					...more to be added.
			 	</p>
				</post>
			</div>
			<div type="response">          
				<post when="Jun 13 '11 at 14:43" who="David T. Macknet" indentLevel="1" upVote="1" >  
					<p>A quibble: 2) is actually bad practice. I see what you're getting at - you want an unique index on that autonumber, and to use it as a surrogate key. But the primary key shouldn't be an autonumber, as that's not what a primary key IS: a primary key is "what the record is about," which (except for things like sales transactions) is NOT the autonumber, but some unique bit of information about the entity being modeled. 
					</p>				
				</post>
			</div>
		<div type="response">       
				<post when="Jun 14 '11 at 1:54" who="FrankComputerAtYmailDotCom" indentLevel="1">  
					<p>the main reason for using autonumber for primary and foreign key is to guarantee that a parent-child join can be maintained irregardless of changes in any other columns. using a different primary key, like customer name or other data can be risky! 
					</p>				
				</post>
			</div>
			<div type="response">       
				<post when="Sep 10 '11 at 20:27" who="FrankComputerAtYmailDotCom" indentLevel="1">  
					<p>@David: I stand corrected!.. its not necessary to use autonumber as the primary key, one can still have an indexed serial column in the parent, joining the surrogate in the child to guarantee the relation will not be severed, while having another column as a meaningful primary to locate the row! 
					</p>				
				</post>
			</div>
			<div type="response">       
				<post when="Sep 13 '11 at 12:46" who="David T. Macknet" indentLevel="1">  
					<p>It's an issue of semantics, at the end of the day ... and Microsoft prefers primary keys to be meaningless, rather than meaningful. Debates around it rage on, but I fall into the "meaningful" camp. :) 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="" who="WhoIsNinja" revisedBy="community wiki" revisedWhen="Jan 24 '11 at 18:37" upVote="9" >
			 	<p>Not taking a backup before fixing some issue inside production database.

					Using DDL commands on stored objects(like tables, views) in stored procedures.

					Fear of using stored proc or fear of using ORM queries wherever the one is more efficient/appropriate to use.

					Ignoring the use of a database profiler, which can tell you exactly what your ORM query is being converted into finally and hence verify the logic or even for debugging when not using ORM.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Mar 7 '09 at 14:22" who="Nathan Voxland" revisedBy="community wiki" upVote="8" >
			 	<p>Not doing the correct level of normalization. You want to make sure that data is not duplicated, and that you are splitting data into different as needed. You also need to make sure you are not following normalization too far as that will hurt performance.
			 	</p>
				</post>
			</div>
		<div type="response">       
				<post when="Mar 7 '09 at 15:59" who="finnw" indentLevel="1">  
					<p>How far is too far? If no data is duplicated how can you take it further?    
					</p>				
				</post>
			</div>
			<div type="response">      
				<post when="Mar 7 '09 at 16:32" who="Nathan Voxland" indentLevel="1">  
					<p>Normalization is a balance of removing redundant data and increasing flexibility vs decreased performance and increased complexity. Finding the correct balance takes experience and it changes over time. See en.wikipedia.org/wiki/Database_normalization for information on when to denormalize 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Mar 7 '09 at 16:02" who="finnw" revisedBy="community wiki" upVote="8" >
			 	<p>Treating the database as just a storage mechanism (i.e. glorified collections library) and hence subordinate to their application (ignoring other applications which share the data)
			 	</p>
				</post>
			</div>
				<div type="response">         
				<post when="Jun 18 '10 at 17:08" who="David Lively" indentLevel="1">  
					<p>A corollary to to this is offloading too much query work to the application instead of keeping it in the db where it belongs. LINQ is particularly bad about this.
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Apr 2 '09 at 18:33" who="Adam Jaskiewicz" revisedBy="community wiki" upVote="8" >
			 	<p>Dismissing an ORM like Hibernate out of hand, for reasons like "it's too magical" or "not on my database".
				Relying too heavily on an ORM like Hibernate and trying to shoehorn it in where it isn't appropriate.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="John Nilsson" revisedBy="community wiki" revisedWhen="Oct 4 '10 at 11:05" upVote="8" >
			 	<p>1 - Unnecessarily using a function on a value in a where clause with the result of that index not being used.

					Example:

					where to_char(someDate,'YYYYMMDD') between :fromDate and :toDate
					instead of

					where someDate &gt;= to_date(:fromDate,'YYYYMMDD') and someDate &lt; to_date(:toDate,'YYYYMMDD')+1
					And to a lesser extent: Not adding functional indexes to those values that need them...

					2 - Not adding check constraints to ensure the validity of the data. Constraints can be used by the query optimizer, and they REALLY help to ensure that you can trust your invariants. There's just no reason not to use them.

					3 - Adding unnormalized columns to tables out of pure laziness or time pressure. Things are usually not designed this way, but evolve into this. The end result, without fail, is a ton of work trying to clean up the mess when you're bitten by the lost data integrity in future evolutions.

					Think of this, a table without data is very cheap to redesign. A table with a couple of millions records with no integrity... not so cheap to redesign. Thus, doing the correct design when creating the column or table is amortized in spades.

					4 - not so much about the database per se but indeed annoying. Not caring about the code quality of SQL. The fact that your SQL is expressed in text does not make it OK to hide the logic in heaps of string manipulation algorithms. It is perfectly possible to write SQL in text in a manner that is actually readable by your fellow programmer.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Jul 28 '09 at 20:23" who="pbailey19" revisedBy="community wiki" upVote="7" >
			 	<p>This has been said before, but: indexes, indexes, indexes. I've seen so many cases of poorly performing enterprise web apps that were fixed by simply doing a little profiling (to see which tables were being hit a lot), and then adding an index on those tables. This doesn't even require much in the way of SQL writing knowledge, and the payoff is huge.

					Avoid data duplication like the plague. Some people advocate that a little duplication won't hurt, and will improve performance. Hey, I'm not saying that you have to torture your schema into Third Normal Form, until it's so abstract that not even the DBA's know what's going on. Just understand that whenever you duplicate a set of names, or zipcodes, or shipping codes, the copies WILL fall out of when with each other eventually. It WILL happen. And then you'll be kicking yourself as you run the weekly maintenance script.

					And lastly: use a clear, consistent, intuitive naming convention. In the same way that a well written piece of code should be readable, a good SQL schema or query should be readable and practically tell you what it's doing, even without comments. You'll thank yourself in six months, when you have to to maintenance on the tables.  "SELECT account_number, billing_date FROM national_accounts" is infinitely easier to work with than "SELECT ACCNTNBR, BILLDAT FROM NTNLACCTS".
			 	</p>
				</post>
			</div>
			<div type="response">         
				<post when="Oct 20 '09 at 13:45" who="HLGEM" indentLevel="1">  
					<p>If you set them up correctly they won't but this involves the use of triggers which many people are allergic to. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Jan 6 '10 at 12:11" who="jamolkhon" revisedBy="community wiki" upVote="6" >
			 	<p>Not executing a corresponding SELECT query before running the DELETE query (particularly on production databases)!
			 	</p>
				</post>
			</div>
			<div type="response">         
				<post when="Jan 10 '11 at 11:51" who="ZeroBugBounce" indentLevel="1">  
					<p>I don't understand the reason for this - can you cite some article or explain why?   
					</p>				
				</post>
			</div>
			<div type="response">         
				<post when="Feb 11 '11 at 2:57" who="Vimvq1987" indentLevel="1">  
					<p>@ZeroBugBounce: to make sure you're deleting the right data!  
					</p>				
				</post>
			</div>
			<div type="response">          
				<post when="Feb 17 '11 at 5:58" who="ZeroBugBounce" indentLevel="1">  
					<p>@Vimvq1987 Ah okay, I was imagining this inside an app, not the case of sitting in front of a database tool. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Jan 29 '11 at 3:56" who="Skatterbrainz" revisedBy="community wiki" upVote="5" >
			 	<p>The most common mistake I've seen in twenty years: not planning ahead. Many developers will create a database, and tables, and then continually modify and expand the tables as they build out the applications. The end result is often a mess and inefficient and difficult to clean up or simplify later on.
			 	</p>
				</post>
			</div>
			<div type="response">        
				<post when="Jan 29 '11 at 12:36" who="Zsolt Török" indentLevel="1" upVote="1" >  
					<p>I can imagine the horrors that ensue in these situations... Schemaless databases are a much better fit for rapid prototyping and iterative development, but like everything else, such flexibility comes with various trade-offs. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="" who="Benoit" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:29" upVote="4" >
			 	<p>a) Hardcoding query values in string
				b) Putting the database query code in the "OnButtonPress" action in a Windows Forms application

					I have seen both.
			 	</p>
				</post>
				</div>
			<div type="response">          
				<post when="Mar 7 '09 at 15:52" who="recursive" indentLevel="1" upVote="4" >  
					<p>"Putting the DB query code in the "OnButtonPress" action in a Windows Form application" What's the database mistake here? 
					</p>				
				</post>
			</div>
			<div type="response">           
				<post when="Mar 16 '09 at 23:41" who="Bill Karwin" indentLevel="1">  
					<p>@recursive: it's a huge SQL injection vulnerability. Anyone can send arbitrary SQL to your server and it will be run verbatim. 
					</p>				
				</post>
			</div>
			<div type="response">         
				<post when="Aug 29 '09 at 15:10" who="p.campbell" indentLevel="1">  
					<p>Agreed with @recursive. These really have nothing to do with DB issues.    
					</p>				
				</post>
			</div>
			<div type="response">    
				<post when="Jun 18 '10 at 17:11" who="David Lively" indentLevel="1">  
					<p>b) is an architecture mistake. Of course, coding queries directly in your app is a bad idea, anyway. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Mar 29 '09 at 13:38" who="chefsmart" revisedBy="Peter Mortensen" revisedWhen="Sep 23 '10 at 17:32" upVote="4" >
			 	<p>Not paying enough attention towards managing database connections in your application. Then you find out the application, the computer, the server, and the network is clogged.
			 	</p>
				</post>
				</div>
			<div type="answer">
				<post when="Jan 5 '11 at 13:55" who="jonesy" revisedBy="community wiki" upVote="4" >
			 	<p>Thinking that they are DBAs and data modelers/designers when they have no formal indoctrination of any kind in those areas.

					Thinking that their project doesn't require a DBA because that stuff is all easy/trivial.

					Failure to properly discern between work that should be done in the database, and work that should be done in the app.

					Not validating backups, or not backing up.

					Embedding raw SQL in their code.
			 	</p>
				</post>
			</div>
			<div type="response">         
				<post when="Jun 13 '11 at 14:45" who="David T. Macknet" indentLevel="1">  
					<p>+1 for #5. Truly - it's a horror to work with one of these apps!       
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Mar 7 '09 at 17:07" who="Charles Faiga" revisedBy="community wiki" upVote="3" >
			 	<p>Here is a link to video called ‘Classic Database Development Mistakes and five ways to overcome them’ by Scott Walz
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="Einstein" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:33" upVote="3" >
			 	<p>Not having an understanding of the databases concurrency model and how this affects development. It's easy to add indexes and tweak queries after the fact. However applications designed without proper consideration for hotspots, resource contention and correct operation (Assuming what you just read is still valid!) can require significant changes within the database and application tier to correct later.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Dec 13 '10 at 15:42" who="Shane H" revisedBy="community wiki" upVote="3" >
			 	<p>Not understanding how a DBMS works under the hood.

					You cannot properly drive a stick without understanding how a clutch works. And you cannot understand how to use a Database without understanding that you are really just writing to a file on your hard disk.

				Specifically:

				Do you know what a Clustered Index is? Did you think about it when you designed your schema?

				Do you know how to use indexes properly? How to reuse an index? Do you know what a Covering Index is?

					So great, you have indexes. How big is 1 row in your index? How big will the index be when you have a lot of data? Will that fit easily into memory? If it won't it's useless as an index.

				Have you ever used EXPLAIN in MySQL? Great. Now be honest with yourself: Did you understand even half of what you saw? No, you probably didn't. Fix that.

				Do you understand the Query Cache? Do you know what makes a query un-cachable?

				Are you using MyISAM? If you NEED full text search, MyISAM's is crap anyway. Use Sphinx. Then switch to Inno.
			 	</p>
				</post>
			</div>
			<div type="response">            
				<post when="Dec 13 '10 at 16:08" who="Michael Easter" indentLevel="1" upVote="2" >  
					<p>A better analogy might be that one cannot properly troubleshoot a manual transmission without understanding a clutch. Plenty of people properly drive a stick-shift without knowing how a clutch works. 
					</p>				
				</post>
			</div>
			<div type="response">             
				<post when="Dec 13 '10 at 18:01" who="Shane H" indentLevel="1">  
					<p>I disagree. I don't think you can optimally use a clutch without understanding how it works. That was a belief passed down 3 generations in my family and one I have experienced first-hand. The difference, the way I was able to drive the car, after I rebuilt the clutch with my father, was night and day. 
					</p>				
				</post>
			</div>
			<div type="response">              
				<post when="Dec 13 '10 at 18:32" who="DOK" indentLevel="1">  
					<p>I have to get out the manual just to remember how to open the hood (or boot for some folks). Everything I know about clutches came from the time my clutch cable broke while I was driving down a steep hill in Berkeley. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Dec 13 '10 at 17:36" who="Sriram" revisedBy="community wiki" upVote="3" >
			 	<p>Using an ORM to do bulk updates
					Selecting more data than needed. Again, typically done when using an ORM
					Firing sqls in a loop.
					Not having good test data and noticing performance degradation only on live data.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Jan 4 '11 at 21:42" who="Nick Anderegg" revisedBy="community wiki" upVote="3" >
			 	<p>Well, I would have to say that the biggest mistake application developers make is not properly normalizing the database.

					As an application developer myself, I realize the importance of proper database structure, normalization, and maintenance; I have spent countless hours educating myself on database structure and administration. In my experience, whenever I start working with a different developer, I usually have to restructure the entire database and update the app to suit because it is usually malformed and defective.

					For example, I started working with a new project where the developer asked me to implement Facebook Connect on the site. I cracked open the database to see what I had to work with and saw that every little bit of information about any given user was crammed into one table. It took me six hours to write a script that would organize the table into four or five separate tables and another two to get the app to use those tables. Please, normalize your databases! It will make everything else less of a headache.
			 	</p>
				</post>
			</div>
			<div type="response">              
				<post when="Jan 4 '11 at 22:32" who="Macke" indentLevel="1">  
					<p>"Whenever I start working with a different developer, I usually have to restructure the entire database." ... I was like this with code formatting once. I've gotten over it. 
					</p>				
				</post>
			</div>
			<div type="response">              
				<post when="Jan 4 '11 at 23:03" who="Alix Axel" indentLevel="1">  
					<p>@Marcus: Don't give up, code (and schema) standards are trés important!    
					</p>				
				</post>
			</div>
			<div type="response">                
				<post when="Jan 5 '11 at 9:24" who="Macke" indentLevel="1">  
					<p>@Alix: I'm saying that reformatting/rewriting every thing on first contact is not, IMO, the right thing to do. Now, setting a worthy goal and pursuing it relentlessly throughout a project is another thing. (Perhaps I reacted to strongly to Nick's statement.) 
					</p>				
				</post>
			</div>
			<div type="response">                
				<post when="Jan 11 '11 at 22:29" who="Nick Anderegg" indentLevel="1">  
					<p>Well, the developer wanted me to implement Facebook Connect, Twitter account integration, etc. I'm a specialist in several areas, social media integration being one of them. The developer that wanted it already had the previous version of the Graph API integrated... right in the user data table. That just would not do, so I ended up having to restructure the entire thing just to get everything to match up correctly. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Mar 7 '09 at 14:54" who="jfar" revisedBy="community wiki" upVote="2" >
			 	<p>Blaming the db engine when the query that ran sooo fast on your development machine blows up and choke once you throw some traffic at the application.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="Robin" revisedBy="community wiki" revisedWhen="Sep 13 '10 at 19:22" upVote="2" >
			 	<p>Very large transactions, inserting/updating a lot of data and then reloading it. Basically this is down to not considering the multi-user environment the database works in.

					Overuse of functions, specifically as results in selects and in where clauses which causes the function to be called over and over again for the results. This, I think, fits under the general case of them trying to work in the procedural fashion they're more used to rather than use SQL to its full advantage.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Dec 13 '10 at 13:02" who="jcampbell1" revisedBy="community wiki" upVote="2" >
			 	<p>15 - Using some crazy construct and application logic instead of a simple COALESCE.
			 	</p>
				</post>
            </div>
			<div type="answer">
				<post when="Jan 5 '11 at 16:12" who="Oakcool" revisedBy="community wiki" upVote="2" >
			 	<p>I think the biggest mistakes that all developers and DBAs do is believing too much on conventions. What I mean by that is that convention are only guide lines that for most cases will work but not necessarily always. I great example is normalization and foreign keys, I know most people wont like this, but normalization can cause complexity and cause loss of performance as well, so if there is no reason to move a phone number to a phones table, don't do it. On the foreign keys, they are great for most cases, but if you are trying to create something that can work by it self when needed the foreign key will be a problem in the future, and also you loose performance. Anyways, as I sad rules and conventions are there to guide, and they should always be though of but not necessarily implemented, analysis of each case is what should always be done.
			 	</p>
				</post>
			</div>
			<div type="response">
				<post when="Jan 5 '11 at 17:09" who="jwiscarson" indentLevel="1" upVote="1" >  
					<p>If your biggest problem is that your application developer's databases closely adhere to largely-accepted database design conventions, then you live in a very happy world indeed. 
					</p>				
				</post>
			</div>
			<div type="answer">
				<post when="Mar 11 '11 at 17:39" who="sdc" revisedBy="community wiki" upVote="2" >
			 	<p>Many developers tend to execute multiple queries against the database (often querying one or two tables) extract the results and perform simple operations in java/c/c++ - all of which could have been done with a single SQL statement.

					Many developers often dont realize that on development environments database and app servers are on their laptops - but on a production environment, database and apps server will be on different machines. Hence for every query there is an additional n/w overhead for the data to be passed between the app server and the database server. I have been amazed to find the number of database calls that are made from the app server to the database server to render one page to the user!
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Mar 12 '11 at 14:42" who="Test223345555" revisedBy="community wiki" upVote="2" >
			 	<p>Biggest mistake is having a loop in the code updating or inserting data when a simple set-based solution would do the trick much faster, and much more simple.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="" who="Pratik" revisedBy="community wiki" revisedWhen="Sep 23 '10 at 17:34" upVote="1" >
			 	<p>There is one thing I might add, learn using analytic functions like PARTITION BY, RANK, DENSE_RANK (for Oracle). They are absolutely essential for complex queries.

					Other advice is, if possible, to have a dedicated database developer in your development team who is expert in SQL, database modelling, tuning, etc. (Not a DBA though). Such skill is a great asset.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Dec 13 '10 at 13:51" who="tszming" revisedBy="community wiki" upVote="1" >
			 	<p>If you are using replication (MySQL), following functions are unsafe unless you are using row-based replication.

					USER(), CURRENT_USER() (or CURRENT_USER), UUID(), VERSION(), LOAD_FILE(), and RAND()
					See: http://dev.mysql.com/doc/refman/5.1/en/replication-features-functions.html
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post when="Dec 13 '10 at 16:09" who="George Milliken" revisedBy="community wiki" upVote="1" >
			 	<p>1) Poor understanding of how to properly interact between Java and the database.

					2) Over parsing, improper or no reuse of SQL

					3) Failing to use BIND variables

					4) Implementing procedural logic in Java when SQL set logic in the database would have worked (better).

					5) Failing to do any reasonable performance or scalability testing prior to going into production

					6) Using Crystal Reports and failing to set the schema name properly in the reports

					7) Implementing SQL with Cartesian products due to ignorance of the execution plan (did you even look at the EXPLAIN PLAN?)
			 	</p>
				</post>
			</div>
		</body>
	</text>
</TEI>