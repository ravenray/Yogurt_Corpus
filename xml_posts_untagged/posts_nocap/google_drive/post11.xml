<?xml version="1.0"?>
<TEI>
	<teiHeader>
		<fileDesc>
			<titleStmt>
				<title>How dangerous is it to compare floating point values?</title>
				<author>Proud Member</author>
			</titleStmt>
			<publicationStmt>
				<p>Open Source?</p>
			</publicationStmt>
			<sourceDesc>
				<p> Pulled from StackOverflow: http://stackoverflow.com/questions/10334688/how-dangerous-is-it-to-compare-floating-point-values
				On: May 1, 2015
				</p>
			<listPerson>
				<person xml:id="Proud Member" url="http://stackoverflow.com/users/472300/proud-member">
				<signatureContent>
					<p>Reputation: <num>9,441</num>
					Number of Gold Badges: <num>23</num>
					Number of Silver Badges:<num>95</num>
					Number of Bronze Badges:<num>187</num></p>	
				</signatureContent>
				</person>
				<person xml:id="Soner Gönül">
				<signatureContent>
					<p>Reputation: <num>47,513</num>
					Number of Gold Badges: <num>18</num>
					Number of Silver Badges:<num>89</num>
					Number of Bronze Badges:<num>153</num></p>
				</signatureContent>
				</person>
				<person xml:id="mc10">
				<signatureContent>
					<p>Reputation: <num>6,326</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>19</num>
					Number of Bronze Badges:<num>42</num></p>
				</signatureContent>
				</person>
				<person xml:id="R.." url="http://stackoverflow.com/users/379897/r">
				<signatureContent>
					<p>Reputation: <num>106,552</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>141</num>
					Number of Bronze Badges:<num>335</num></p>
				</signatureContent>
				</person>
				<person xml:id="Daniel Fischer" url="http://stackoverflow.com/users/1011995/daniel-fischer">
				<signatureContent>
					<p>Reputation: <num>120,989</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>189</num>
					Number of Bronze Badges:<num>312</num></p>
				</signatureContent>
				</person>
				<person xml:id="Nicolás" url="http://stackoverflow.com/users/677022/nicol%C3%A1s">
				<signatureContent>
					<p>Reputation: <num>2,873</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>15</num>
					Number of Bronze Badges:<num>31</num></p>
				</signatureContent>
				</person>
				<person xml:id="Stephen Canon" url="http://stackoverflow.com/users/142434/stephen-canon">
				<signatureContent>
					<p>Reputation: <num>64,759</num>
					Number of Gold Badges: <num>11</num>
					Number of Silver Badges:<num>103</num>
					Number of Bronze Badges:<num>177</num></p>
				</signatureContent>
				</person>
				<person xml:id="Zarel" url="http://stackoverflow.com/users/128023/zarel">
				<signatureContent>
					<p>Reputation: <num>1,731</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>9</num>
					Number of Bronze Badges:<num>19</num></p>
				</signatureContent>
				</person>
				<person xml:id="Nemo" url="http://stackoverflow.com/users/768469/nemo">
				<signatureContent>
					<p>Reputation: <num>36,342</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>57</num>
					Number of Bronze Badges:<num>103</num></p>
				</signatureContent>
				</person>
				<person xml:id="Christian Rau" url="http://stackoverflow.com/users/743214/christian-rau">
				<signatureContent>
					<p>Reputation: <num>31,064</num>
					Number of Gold Badges: <num>4</num>
					Number of Silver Badges:<num>42</num>
					Number of Bronze Badges:<num>100</num></p>
				</signatureContent>
				</person>
				<person xml:id="hfossli" url="http://stackoverflow.com/users/202451/hfossli">
				<signatureContent>
					<p>Reputation: <num>9,177 </num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>53</num>
					Number of Bronze Badges:<num>80</num></p>
				</signatureContent>
				</person>
				<person xml:id="supercat" url="http://stackoverflow.com/users/363751/supercat">
				<signatureContent>
					<p>Reputation: <num>31,307</num>
                    Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>41</num>
					Number of Bronze Badges:<num>72</num></p>
				</signatureContent>
				</person>
				<person xml:id="High Performance Mark" url="http://stackoverflow.com/users/44309/high-performance-mark">
				<signatureContent>
					<p>Reputation: <num>54,395</num>
					Number of Gold Badges: <num>3</num>
					Number of Silver Badges:<num>50</num>
					Number of Bronze Badges:<num>95</num></p>
				</signatureContent>
				</person>
				<person xml:id="Almo" url="http://stackoverflow.com/users/290072/almo">
				<signatureContent>
					<p>Reputation: <num>5,499</num>
					Number of Gold Badges: <num>6</num>
					Number of Silver Badges:<num>28</num>
					Number of Bronze Badges:<num>54</num></p>
				</signatureContent>
				</person>
				<person xml:id="Pascal Cuoq" url="http://stackoverflow.com/users/139746/pascal-cuoq">
				<signatureContent>
					<p>Reputation: <num>51,064</num>
					Number of Gold Badges: <num>5</num>
					Number of Silver Badges:<num>75</num>
					Number of Bronze Badges:<num>165</num></p>
				</signatureContent>
				</person>
				<person xml:id="starmole" url="http://stackoverflow.com/users/360270/starmole">
				<signatureContent>
					<p>Reputation: <num>2,321</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>7</num>
					Number of Bronze Badges:<num>28</num></p>
				</signatureContent>
				</person>
				<person xml:id="JHumphrey" url="http://stackoverflow.com/users/1192896/jhumphrey">
				<signatureContent>
					<p>Reputation: <num>425</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>3</num>
					Number of Bronze Badges:<num>9</num></p>
				</signatureContent>
				</person>
				<person xml:id="Michael" url="http://stackoverflow.com/users/91260/michael">
				<signatureContent>
					<p>Reputation: <num>854</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>11</num>
					Number of Bronze Badges:<num>22</num></p>
				</signatureContent>
				</person>
				<person xml:id="Lucas Membrane" url="http://stackoverflow.com/users/911264/lucas-membrane">
				<signatureContent>
					<p>Reputation: <num>164</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num></num>
					Number of Bronze Badges:<num>5</num></p>
				</signatureContent>
				</person>
				<person xml:id="gnasher729">
				<signatureContent>
					<p>Reputation: <num>14,552</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>13</num>
					Number of Bronze Badges:<num>25</num></p>
				</signatureContent>
				</person>
				<person xml:id="GoZoner" url="http://stackoverflow.com/users/1286639/gozoner">
				<signatureContent>
					<p>Reputation: <num>20,247</num>
					Number of Gold Badges: <num>2</num>
					Number of Silver Badges:<num>23</num>
					Number of Bronze Badges:<num>62</num></p>
				</signatureContent>
				</person>
				<person xml:id="Romain" url="http://stackoverflow.com/users/223339/romain">
				<signatureContent>
					<p>Reputation: <num>7,688</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>15</num>
					Number of Bronze Badges:<num>35</num></p>
				</signatureContent>
				</person>
				<person xml:id="Matt Melton">
				<signatureContent>
					<p>Reputation: <num>1,669</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num>6</num>
					Number of Bronze Badges:<num>17</num></p>
				</signatureContent>
				</person>
				<person xml:id="John White" url="http://stackoverflow.com/users/272858/john-white">
				<signatureContent>
					<p>Reputation: <num>133</num>
					Number of Gold Badges: <num></num>
					Number of Silver Badges:<num></num>
					Number of Bronze Badges:<num>10</num></p>
				</signatureContent>
				</person>
				<person xml:id="Tom Swirly" url="http://stackoverflow.com/users/43839/tom-swirly">
				<signatureContent>
					<p>Reputation: <num>1,259</num>
					Number of Gold Badges: <num>1</num>
					Number of Silver Badges:<num>11</num>
					Number of Bronze Badges:<num>20</num></p>
				</signatureContent>
				</person>
				</listPerson>
			</sourceDesc>
		</fileDesc>
	</teiHeader>
	<text>
		<body>
		<div type="forum">
			<post synch="Apr 26 '12 at 13:41" who="Proud Member" revisedWhen="Apr 30 '12 at 11:13" revisedBy="Soner Gönül" upVote="236" accepted="favorite">
			<p>I know UIKit uses CGFloat because of the resolution independent coordinate system.

				But every time I want to check if for example frame.origin.x is 0 it makes me feel sick:

				if (theView.frame.origin.x == 0) {
				    // do important operation
				}
				Isn't CGFloat vulnerable to false positives when comparing with ==, &lt;=, &gt;=, &lt;, &gt;? It is a floating point and they have unprecision problems: 0.0000000000041 for example.

				Is Objective-C handling this internally when comparing or can it happen that a origin.x which reads as zero does not compare to 0 as true?

				<tag>objective-c</tag> <tag>ios</tag> <tag>c</tag> <tag>floating-point</tag> <tag>floating-accuracy</tag>
			</p>
			</post>	
		</div>		
			<div type="answer">
				<post synch="Apr 26 '12 at 14:33" who="R.." revisedWhen="May 15 '12 at 3:48" revisedBy="mc10" upVote="311">
			 	<p>First of all, floating point values are not "random" in their behavior. Exact comparison can and does make sense in plenty of real-world usages. But if you're going to use floating point you need to be aware of how it works. Erring on the side of assuming floating point works like real numbers will get you code that quickly breaks. Erring on the side of assuming floating point results have large random fuzz associated with them (like most of the answers here suggest) will get you code that appears to work at first but ends up having large-magnitude errors and broken corner cases.

				First of all, if you want to program with floating point, you should read this:

				What Every Computer Scientist Should Know About Floating-Point Arithmetic

				Yes, read all of it. If that's too much of a burden, you should use integers/fixed point for your calculations until you have time to read it. :-)

				Now, with that said, the biggest issues with exact floating point comparisons come down to:

				The fact that lots of values you may write in the source, or read in with scanf or strtod, do not exist as floating point values and get silently converted to the nearest approximation. This is what demon9733's answer was talking about.

				The fact that many results get rounded due to not having enough precision to represent the actual result. An easy example where you can see this is adding x = 0x1fffffe and y = 1 as floats. Here, x has 24 bits of precision in the mantissa (ok) and y has just 1 bit, but when you add them, their bits are not in overlapping places, and the result would need 25 bits of precision. Instead, it gets rounded (to 0x2000000` in the default rounding mode).

				The fact that many results get rounded due to needing infinitely many places for the correct value. This includes both rational results like 1/3 (which you're familiar with from decimal where it takes infinitely many places) but also 1/10 (which also takes infinitely many places in binary, since 5 is not a power of 2), as well as irrational results like the square root of anything that's not a perfect square.

				Double rounding. On some systems (particularly x86), floating point expressions are evaluated in higher precision than their nominal types. This means that when one of the above types of rounding happens, you'll get two rounding steps, first a rounding of the result to the higher-precision type, then a rounding to the final type. As an example, consider what happens in decimal if you round 1.49 to an integer (1), versus what happens if you first round it to one decimal place (1.5) then round that result to an integer (2). This is actually one of the nastiest areas to deal with in floating point, since the behavior of the compiler (especially for buggy, non-conformant compilers like GCC) is unpredictable.

				Transcendental functions (trig, exp, log, etc.) are not specified to have correctly rounded results; the result is just specified to be correct within one unit in the last place of precision (usually referred to as 1ulp).

				When you're writing floating point code, you need to keep in mind what you're doing with the numbers that could cause the results to be inexact, and make comparisons accordingly. Often times it will make sense to compare with an "epsilon", but that epsilon should be based on the magnitude of the numbers you are comparing, not an absolute constant. (In cases where an absolute constant epsilon would work, that's strongly indicative that fixed point, not floating point, is the right tool for the job!)

				Edit: In particular, a magnitude-relative epsilon check should look something like:

				if (fabs(x-y) &lt; K * FLT_EPSILON * fabs(x+y))
				Where FLT_EPSILON is the constant from float.h (replace it with DBL_EPSILON for doubles or LDBL_EPSILON for long doubles) and K is a constant you choose such that the accumulated error of your computations is definitely bounded by K units in the last place (and if you're not sure you got the error bound calculation right, make K a few times bigger than what your calculations say it should be).

				Finally, note that if you use this, some special care may be needed near zero, since FLT_EPSILON does not make sense for denormals. A quick fix would be to make it:

				if (fabs(x-y) &lt; K * FLT_EPSILON * fabs(x+y) || fabs(x-y) &lt; FLT_MIN)
				and likewise substitute DBL_MIN if using doubles.
			 	</p>
				</post>
			</div>
			<div type="response">
				<post synch="Apr 26 '12 at 15:20" who="Daniel Fischer" IndentLevel="1"  upVote="17">      
				<p>fabs(x+y) is problematic if x and y (can) have different sign. Still, a good answer against the tide of cargo-cult comparisons.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 26 '12 at 15:41" who="R.." IndentLevel="1"  upVote="16">         
				<p>If x and y have different sign, it's no problem. The righthand side will be "too small", but since x and y have different sign, they should not compare equal anyway. (Unless they are so small as to be denormal, but then the second case catches it) 
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 26 '12 at 15:41" who="R.." IndentLevel="1"  upVote="5">        
				<p>@Daniel: +1 to your comment anyway for invoking the word "cargo-cult". :-)    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 26 '12 at 15:44" who="R.." IndentLevel="1"  upVote="10">      
				<p>@yms: Maybe it was a little too harsh, but to borrow Daniel's choice of words, there's a huge amount of cargo-culting going on in the answers to this question as is usual among floating point questions. I don't think it's helpful to answer questions about a topic you don't understand with cargo-cult answers, and in fact most of the answers here are probably deserving of downvotes for that very reason, but I specifically stated that I'm not doing it lest I be accused of being one of the downvoters if/when they get downvoted.   
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 26 '12 at 21:04" who="Nicolás" IndentLevel="1"  upVote="1">         
				<p>I'm curious about your statement: "especially for buggy, non-conformant compilers like GCC". Is really GCC buggy and also non-conformant?    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 27 '12 at 0:25" who="R.." IndentLevel="1">         
				<p>@Nicolás: The C standard allows expressions to be evaluated in higher precision than their nominal type (for example, float expressions can be evaluated as double or long double) and specifies the FLT_EVAL_METHOD macro that tells the application whether this will happen. So gcc is justified in using higher precision. However, the C standard also requires storage to a variable and explicit casts (and possibly some other situations) to throw away the extra precision. With -ffloat-store, gcc honors the requirement for storage to a variable but not for casts; without it gcc is all wrong.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 27 '12 at 0:29" who="R.." IndentLevel="1"  upVote="3">          
				<p>Actually GCC is wrong on a number of other things too. For example, it wrongly optimizes out code that would effect the floating point exception flags, and compiles comparisons (at least on x86) to the wrong instruction that does not raise the invalid exception flag on encountering a NAN. It also ignores the STDC FENV pragmas, and generates intrinsic sqrt that is not correctly rounded. Some of these things are fixable with -f options, but GCC's floating point behavior is generally to be fast at the expense of being wrong unless you request otherwise (and sometimes still wrong).   
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 27 '12 at 12:09" who="R.." IndentLevel="1"  upVote="10">          
				<p>I just discovered gcc beginning somewhere in the 4.5 or 4.6 series has an option -fexcess-precision=standard, enabled by default with -std=c99 or -std=c11, that behaves like -ffloat-store but also handles casts, and disables the incorrect sqrt optimization. With these fixes, GCC's floating point on x86 seems very close to being IEEE conformant now. By default it's still badly broken, but hopefully good programs will use -std=c99. (Also note -std=gnu99 does not fix it.)    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Apr 27 '12 at 23:09" who="Nicolás" IndentLevel="1">          
				<p>Thanks @R.. for your complete explanations! It's good to know that the option -std=c99 is useful to circumvent this problem.   
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 11 '12 at 14:46" who="Stephen Canon" IndentLevel="1"  upVote="1">         
				<p>Since the question is tagged iOS, it's worth noting that Apple's compilers (both clang and Apple's gcc builds) have always used FLT_EVAL_METHOD = 0, and attempt to be completely strict about not carrying excess precision. If you find any violations of that, please file bug reports. 
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 11 '12 at 16:05" who="R.." IndentLevel="1">         
				<p>@StephenCanon: How can they do this for pre-SSE2 x86 targets? I think that's impossible without using either soft-float or just using SSE2 anyway and having emulation traps in the kernel. Just doing the arithmetic in higher precision then truncating (like gcc's -ffloat-store) yields incorrect double-rounding, and even switching the FPU's control word to lower precision results in double rounding for denormals (since the exponent range is still 15 bit and thus denormals don't underflow like they should).    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 11 '12 at 16:07" who="Stephen Canon" IndentLevel="1">       
				<p>@R..: Apple never shipped an x86 processor without SSE2. All arithmetic other than long double is done on SSE, even on 32-bit.  
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 11 '12 at 16:15" who="R.." IndentLevel="1">          
				<p>OK that makes sense, but I think your usage of "Apple's compilers" was unclear. I assumed it applied to clang (Apple's compiler) on any target rather than just on Apple systems.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 14 '12 at 5:46" who="Zarel" IndentLevel="1">          
				<p>This answer doesn't seem to explain how "erring on the side of assuming floating point results have large random fuzz associated with them will get you code that appears to work at first but ends up having large-magnitude errors and broken corner cases."  
				</p>
				</post> 
				</div>
				<div type="response">
				<post synch="May 14 '12 at 15:43" who="R.." IndentLevel="1">        
				<p>@Zarel: "Large" random fuzz is usually handled as an absolute epsilon value. For very-large magnitude numbers, the epsilon is below their precision and thus "epsilon comparisons" degenerate into exact-equality comparisons. Conversely, for very small numbers, an absolute epsilon comparison can make 1000000*x and x look equal. These are the broken corner cases I was referring to. Large errors just refers to the fact that if you treat x and y as equal when only their exponents and half their mantissas match, you essentially threw away half your mantissa precision...    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Dec 19 '12 at 1:57" who="Nemo" IndentLevel="1">         
				<p>@R.: You might find this question interesting. I would certainly like to know your opinion on it, if any.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Jul 5 '13 at 16:17" who="Christian Rau" IndentLevel="1"  upVote="7">         
				<p>"First of all, floating point values are not "random" in their behavior. Exact comparison can and does make sense in plenty of real-world usages." - Just two sentences and already earned a +1! That's one of the most disturbing misassumptions people make when working with floating points.   
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="May 14 '14 at 11:25" who="hfossli" IndentLevel="1">        
				<p>@R.. Would you approve this? gist.github.com/hfossli/4616c778bea3a334f034 I replaced "K" with "accuracy" if that makes sense.   
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Jul 9 '14 at 23:40" who="supercat" IndentLevel="1">          
				<p>An issue not yet mentioned in this answer's list is that if a computation yields a "not a number" result, that answer will compare unequal to itself. That's not an issue when comparing a variable to a constant that isn't a NaN, but can be an issue when e.g. testing whether a floating-point value is in a table.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Jul 9 '14 at 23:45" who="supercat" IndentLevel="1"  upVote="2">        
				<p>@hfossli: The fundamental question floating-point equality tests are intended to answer is generally "In the absence of rounding errors, could two calculations have yielded the same result"? To determine that, one must know what sorts of rounding errors may have occurred. Any "general-purpose" comparison method is apt to either be way too tolerant in cases where rounding errors would have been slight, or way too strict in cases where they could have been severe.    
				</p>
				</post>
				</div>
			<div type="answer">
				<post synch="Apr 26 '12 at 13:55" who="High Performance Mark" revisedWhen="Dec 16 '13 at 9:59"  upVote="28">
			 	<p>Since 0 is exactly representable as an IEEE754 floating-point number (or using any other implementation of f-p numbers I've ever worked with) comparison with 0 is probably safe. You might get bitten, however, if your program computes a value (such as theView.frame.origin.x) which you have reason to believe ought to be 0 but which your computation cannot guarantee to be 0.

				To clarify a little, a computation such as :

				areal = 0.0
				will (unless your language or system is broken) create a value such that (areal==0.0) returns true but another computation such as

				areal = 1.386 - 2.1*(0.66)
				may not.

				If you can assure yourself that your computations produce values which are 0 (and not just that they produce values which ought to be 0) then you can go ahead and compare f-p values with 0. If you can't assure yourself to the required degree, best stick to the usual approach of 'toleranced equality'.

				In the worst cases the careless comparison of f-p values can be extremely dangerous: think avionics, weapons-guidance, power-plant operations, vehicle navigation, almost any application in which computation meets the real world.

				For Angry Birds, not so dangerous.
			 	</p>
				</post>
			</div>
			<div type="response">
				<post synch="Apr 26 '12 at 14:12" who="Almo" IndentLevel="1"  upVote="13">      
				<p>Re: Angry Birds: Financially, a bug the stops 10 million gamers from squishing the Pigs could have repurcussions.    
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Aug 6 '13 at 17:04" who="Pascal Cuoq" IndentLevel="1"  upVote="4">         
				<p>Actually, 1.30 - 2*(0.65) is a perfect example of an expression that obviously evaluates to 0.0 if your compiler implements IEEE 754, because the doubles represented as 0.65 and 1.30 have the same significands, and multiplication by two is obviously exact.     
				</p>
				</post>
				</div>
				<div type="response">
				<post synch="Dec 16 '13 at 10:00" who="High Performance Mark" IndentLevel="1">        
				<p>Still getting rep from this one, so I changed the second example snippet.    
				</p>
				</post>
				</div>
			<div type="answer">
				<post synch="May 14 '12 at 4:19" who="starmole" revisedWhen="May 22 '12 at 7:38"  upVote="18">
			 	<p>I want to give a bit of a different answer than the others. They are great for answering your question as stated but probably not for what you need to know or what your real problem is.

				Floating point in graphics is fine! But there is almost no need to ever compare floats directly. Why would you need to do that? Graphics uses floats to define intervals. And comparing if a float is within an interval also defined by floats is always well defined and merely needs to be consistent, not accurate or precise! As long as a pixel (which is also an interval!) can be assigned that's all graphics needs.

				So if you want to test if your point is outside a [0..width[ range this is just fine. Just make sure you define inclusion consistently. For example always define inside is (x&gt;=0 &amp;&amp; x &lt; width). The same goes for intersection or hit tests.

				However, if you are abusing a graphics coordinate as some kind of flag, like for example to see if a window is docked or not, you should not do this. Use a boolean flag that is separate from the graphics presentation layer instead.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post synch="May 14 '12 at 3:48" who="JHumphrey"  upVote="12">
			 	<p>Comparing to zero can be a safe operation, as long as the zero wasn't a calculated value (as noted in an above answer). The reason for this is that zero is a perfectly representable number in floating point.

				Talking perfectly representable values, you get 24 bits of range in a power-of-two notion (single precision). So 1, 2, 4 are perfectly representable, as are .5, .25, and .125. As long as all your important bits are in 24-bits, you are golden. So 10.625 can be repsented precisely.

				This is great, but will quickly fall apart under pressure. Two scenarios spring to mind: 1) When a calculation is involved. Don't trust that sqrt(3)*sqrt(3) == 3. It just won't be that way. And it probably won't be within an epsilon, as some of the other answers suggest. 2) When any non-power-of-2 (NPOT) is involved. So it may sound odd, but 0.1 is an infinite series in binary and therefore any calculation involving a number like this will be imprecise from the start.

				(Oh and the original question mentioned comparisons to zero. Don't forget that -0.0 is also a perfectly valid floating-point value.)
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post synch="May 7 '13 at 12:09" who="Michael"  upVote="4">
			 	<p>The correct question: how does one compare points in Cocoa Touch?

				The correct answer: CGPointEqualToPoint().

				A different question: Are two calculated values are the same?

				The answer posted here: They are not.

				How to check if they are close? If you want to check if they are close, then don't use CGPointEqualToPoint(). But, don't check to see if they are close. Do something that makes sense in the real world, like checking to see if a point is beyond a line or if a point is inside a sphere.
			 	</p>
				</post>
			</div>
			<div type="answer">
				<post synch="May 14 '12 at 1:41" who="Lucas Membrane"  upVote="3">
			 	<p>The last time I checked the C standard, there was no requirement for floating point operations on doubles (64 bits total, 53 bit mantissa) to be accurate to more than that precision. However, some hardware might do the operations in registers of greater precision, and the requirement was interpreted to mean no requirement to clear lower order bits (beyond the precision of the numbers being loaded into the registers). So you could get unexpected results of comparisons like this depending on what was left over in the registers from whoever slept there last.

				That said, and despite my efforts to expunge it whenever I see it, the outfit where I work has lots of C code that is compiled using gcc and run on linux, and we have not noticed any of these unexpected results in a very long time. I have no idea whether this is because gcc is clearing the low-order bits for us, the 80-bit registers are not used for these operations on modern computers, the standard has been changed, or what. I'd like to know if anyone can quote chapter and verse.
			 	</p>
				</post>
			</div>
			<div type="response">
			<post synch="Apr 30 '14 at 12:46" who="gnasher729" IndentLevel="1">        
				<p>Since the time that Intel processors have SSE2 and better, compilers tend to do double precision floating-point arithmetic using the SSE 64 bit floating point registers, and not the slower 80 bit floating-point check. That would only be used if you use "long double" instead of double. The requirement was always that storing a value into a double lvalue, or an explicit cast to double, should reduce the precision, but gcc tended to be not very good at it. For example, the compiler treated a cast of a double value to double as a no-op which is wrong when the value is actually 80 bit.    
				</p>
				</post>
				</div>
			<div type="answer">
				<post synch="Apr 26 '12 at 13:51" who="GoZoner" revisedWhen="Jun 3 '14 at 13:32"  upVote="3">
			 	<p>Precisely because of round errors, you should not use comparison of 'exact' values for logical operations. In your specific case of a position on a visual display, it can't possibly matter if the position is 0.0 or 0.0000000003 - the difference is invisible to the eye. So your logic should be something like:

				#define VISIBLE_SHIFT    0.0001        // for example
				if (fabs(theView.frame.origin.x) &lt; VISIBLE_SHIFT) { /* ... */ }
				[EDIT, comparing to 'right answer'] The 'right answer' above says:

				K is a constant you choose such that the accumulated error of your computations is definitely bounded by K units in the last place (and if you're not sure you got the error bound calculation right, make K a few times bigger than what your calculations say it should be)
				So we need K. If getting K is more difficult, less intuitive than selecting my VISIBLE_SHIFT then you'll decide what works for you. To find K we are going to write a test program that looks at a bunch of K values so we can see how it behaves. Ought to be obvious how to choose K, if the 'right answer' is usable. No?

				We are going to use:

				if (fabs(x-y) &lt; K * DBL_EPSILON * fabs(x+y) || fabs(x-y) &lt; DBL_MIN)
				Let's just try all values of K:

				#include &lt;math.h>
				#include &lt;float.h>
				#include &lt;stdio.h>

				void main (void)
				{
				  double x = 1e-13;
				  double y = 0.0;

				  double K = 1e22;
				  int i = 0;

				  for (; i &lt; 32; i++, K = K/10.0)
				    {
				      printf ("K:%40.16lf -> ", K);

				      if (fabs(x-y) &lt; K * DBL_EPSILON * fabs(x+y) || fabs(x-y) &lt; DBL_MIN)
				        printf ("YES\n");
				      else
				        printf ("NO\n");
				    }
				}
				ebg@ebg$ gcc -o test test.c
				ebg@ebg$ ./test
				K:10000000000000000000000.0000000000000000 -> YES
				K: 1000000000000000000000.0000000000000000 -> YES
				K:  100000000000000000000.0000000000000000 -> YES
				K:   10000000000000000000.0000000000000000 -> YES
				K:    1000000000000000000.0000000000000000 -> YES
				K:     100000000000000000.0000000000000000 -> YES
				K:      10000000000000000.0000000000000000 -> YES
				K:       1000000000000000.0000000000000000 -> NO
				K:        100000000000000.0000000000000000 -> NO
				K:         10000000000000.0000000000000000 -> NO
				K:          1000000000000.0000000000000000 -> NO
				K:           100000000000.0000000000000000 -> NO
				K:            10000000000.0000000000000000 -> NO
				K:             1000000000.0000000000000000 -> NO
				K:              100000000.0000000000000000 -> NO
				K:               10000000.0000000000000000 -> NO
				K:                1000000.0000000000000000 -> NO
				K:                 100000.0000000000000000 -> NO
				K:                  10000.0000000000000000 -> NO
				K:                   1000.0000000000000000 -> NO
				K:                    100.0000000000000000 -> NO
				K:                     10.0000000000000000 -> NO
				K:                      1.0000000000000000 -> NO
				K:                      0.1000000000000000 -> NO
				K:                      0.0100000000000000 -> NO
				K:                      0.0010000000000000 -> NO
				K:                      0.0001000000000000 -> NO
				K:                      0.0000100000000000 -> NO
				K:                      0.0000010000000000 -> NO
				K:                      0.0000001000000000 -> NO
				K:                      0.0000000100000000 -> NO
				K:                      0.0000000010000000 -> NO
				Ah, so K should be 1e16 or larger if I want 1e-13 to be 'zero'.

				So, I'd say you have two options:

				Do a simple epsilon computation using your engineering judgement for the value of 'epsilon', as I've suggested. If you are doing graphics and 'zero' is meant to be a 'visible change' than examine your visual assets (images, etc) and judge what epsilon can be.
				Don't attempt any floating point computations until you've read the non-cargo-cult answer's reference (and gotten your Ph.D in the process) and then use your non-intuitive judgement to select K.
			 	</p>
				</post>
			</div>
			<div type="response">
			<post synch="Apr 26 '12 at 13:53" who="Romain" IndentLevel="1"  upVote="9">        
				<p>One aspect of resolution-independence is that you cannot tell for sure what a "visible shift" is at compile-time. What is invisible on a super-HD screen might very well be obvious on a tiny-ass screen. One should at least make it a function of screen size. Or name it something else.     
				</p>
				</post>
				</div>
			<div type="response">
				<post synch="Apr 26 '12 at 14:13" who="Matt Melton" IndentLevel="1">        
				<p>should be fabs?  
				</p>
				</post>
				</div>
			<div type="response">
			<post synch="May 14 '12 at 15:14" who="GoZoner" IndentLevel="1">        
				<p>In spite of the down votes, the up-voted comment and the fancy, wordy answer 'if (fabs(x-y) &lt; K * FLT_EPSILON * fabs(x+y))', I still got it right. Note the '// for example' code comment when setting the 'VISIBLE_SHIFT' parameter.      
				</p>
				</post>
				</div>
			<div type="answer">
				<post synch="May 2 '12 at 22:52" who="John White"  downVote="-5">
			 	<p>I'd say the right thing is to declare each number as an object, and then define three things in that object: 1) an equality operator. 2) a setAcceptableDifference method. 3)the value itself. The equality operator returns true if the absolute difference of two values is less than the value set as acceptable.

				You can subclass the object to suit the problem. For example, round bars of metal between 1 and 2 inches might be considered of equal diameter if their diameters differed by less than 0.0001 inches. So you'd call setAcceptableDifference with parameter 0.0001, and then use the equality operator with confidence.
			 	</p>
				</post>
			</div>
			<div type="response">
			<post synch="May 14 '12 at 18:53" who="Tom Swirly" IndentLevel="1"  upVote="1">        
				<p>This is Not A Good Answer. First, the whole "object thing" does nothing whatsoever to solve your issue. And second, your actual implementation of "equality" isn't in fact the correct one.    
				</p>
				</post>
				</div>
				<div type="response">
			<post synch="Aug 16 '12 at 17:53" who="John White" IndentLevel="1"  upVote="2">        
				<p>Tom, maybe you'd think again about the "object thing". With real numbers, represented to high precision, equality rarely happens. But one's idea of equality may be tailored if it suits you. It would be nicer if there was an overridable 'approximately equal' operator, but there ain't.   
				</p>
				</post>
				</div>
		</body>	
	</text>
</TEI>